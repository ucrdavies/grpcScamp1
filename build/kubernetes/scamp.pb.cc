// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scamp.proto

#include "scamp.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

extern PROTOBUF_INTERNAL_EXPORT_scamp_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_RepeatedDouble_scamp_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_scamp_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_RepeatedFloat_scamp_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_scamp_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_RepeatedUInt_scamp_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_scamp_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_RepeatedULong_scamp_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_scamp_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_Profile_scamp_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_scamp_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_SCAMPArgs_scamp_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_scamp_2eproto ::google::protobuf::internal::SCCInfo<4> scc_info_ProfileData_scamp_2eproto;
namespace SCAMPProto {
class SCAMPWorkDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SCAMPWork> _instance;
} _SCAMPWork_default_instance_;
class SCAMPStatusDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SCAMPStatus> _instance;
} _SCAMPStatus_default_instance_;
class SCAMPJobIDDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SCAMPJobID> _instance;
} _SCAMPJobID_default_instance_;
class SCAMPRequestDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SCAMPRequest> _instance;
} _SCAMPRequest_default_instance_;
class SCAMPResultDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SCAMPResult> _instance;
} _SCAMPResult_default_instance_;
class RepeatedUIntDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<RepeatedUInt> _instance;
} _RepeatedUInt_default_instance_;
class RepeatedULongDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<RepeatedULong> _instance;
} _RepeatedULong_default_instance_;
class RepeatedFloatDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<RepeatedFloat> _instance;
} _RepeatedFloat_default_instance_;
class RepeatedDoubleDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<RepeatedDouble> _instance;
} _RepeatedDouble_default_instance_;
class ProfileDataDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ProfileData> _instance;
  const ::SCAMPProto::RepeatedUInt* uint32_value_;
  const ::SCAMPProto::RepeatedULong* uint64_value_;
  const ::SCAMPProto::RepeatedFloat* float_value_;
  const ::SCAMPProto::RepeatedDouble* double_value_;
} _ProfileData_default_instance_;
class ProfileDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Profile> _instance;
} _Profile_default_instance_;
class SCAMPTileInfoDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SCAMPTileInfo> _instance;
} _SCAMPTileInfo_default_instance_;
class SCAMPArgsDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SCAMPArgs> _instance;
} _SCAMPArgs_default_instance_;
}  // namespace SCAMPProto
static void InitDefaultsSCAMPWork_scamp_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SCAMPProto::_SCAMPWork_default_instance_;
    new (ptr) ::SCAMPProto::SCAMPWork();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SCAMPProto::SCAMPWork::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_SCAMPWork_scamp_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsSCAMPWork_scamp_2eproto}, {
      &scc_info_SCAMPArgs_scamp_2eproto.base,}};

static void InitDefaultsSCAMPStatus_scamp_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SCAMPProto::_SCAMPStatus_default_instance_;
    new (ptr) ::SCAMPProto::SCAMPStatus();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SCAMPProto::SCAMPStatus::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_SCAMPStatus_scamp_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsSCAMPStatus_scamp_2eproto}, {}};

static void InitDefaultsSCAMPJobID_scamp_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SCAMPProto::_SCAMPJobID_default_instance_;
    new (ptr) ::SCAMPProto::SCAMPJobID();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SCAMPProto::SCAMPJobID::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_SCAMPJobID_scamp_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsSCAMPJobID_scamp_2eproto}, {}};

static void InitDefaultsSCAMPRequest_scamp_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SCAMPProto::_SCAMPRequest_default_instance_;
    new (ptr) ::SCAMPProto::SCAMPRequest();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SCAMPProto::SCAMPRequest::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_SCAMPRequest_scamp_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsSCAMPRequest_scamp_2eproto}, {}};

static void InitDefaultsSCAMPResult_scamp_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SCAMPProto::_SCAMPResult_default_instance_;
    new (ptr) ::SCAMPProto::SCAMPResult();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SCAMPProto::SCAMPResult::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_SCAMPResult_scamp_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsSCAMPResult_scamp_2eproto}, {}};

static void InitDefaultsRepeatedUInt_scamp_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SCAMPProto::_RepeatedUInt_default_instance_;
    new (ptr) ::SCAMPProto::RepeatedUInt();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SCAMPProto::RepeatedUInt::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_RepeatedUInt_scamp_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsRepeatedUInt_scamp_2eproto}, {}};

static void InitDefaultsRepeatedULong_scamp_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SCAMPProto::_RepeatedULong_default_instance_;
    new (ptr) ::SCAMPProto::RepeatedULong();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SCAMPProto::RepeatedULong::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_RepeatedULong_scamp_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsRepeatedULong_scamp_2eproto}, {}};

static void InitDefaultsRepeatedFloat_scamp_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SCAMPProto::_RepeatedFloat_default_instance_;
    new (ptr) ::SCAMPProto::RepeatedFloat();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SCAMPProto::RepeatedFloat::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_RepeatedFloat_scamp_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsRepeatedFloat_scamp_2eproto}, {}};

static void InitDefaultsRepeatedDouble_scamp_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SCAMPProto::_RepeatedDouble_default_instance_;
    new (ptr) ::SCAMPProto::RepeatedDouble();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SCAMPProto::RepeatedDouble::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_RepeatedDouble_scamp_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsRepeatedDouble_scamp_2eproto}, {}};

static void InitDefaultsProfileData_scamp_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SCAMPProto::_ProfileData_default_instance_;
    new (ptr) ::SCAMPProto::ProfileData();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SCAMPProto::ProfileData::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<4> scc_info_ProfileData_scamp_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 4, InitDefaultsProfileData_scamp_2eproto}, {
      &scc_info_RepeatedUInt_scamp_2eproto.base,
      &scc_info_RepeatedULong_scamp_2eproto.base,
      &scc_info_RepeatedFloat_scamp_2eproto.base,
      &scc_info_RepeatedDouble_scamp_2eproto.base,}};

static void InitDefaultsProfile_scamp_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SCAMPProto::_Profile_default_instance_;
    new (ptr) ::SCAMPProto::Profile();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SCAMPProto::Profile::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_Profile_scamp_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsProfile_scamp_2eproto}, {
      &scc_info_ProfileData_scamp_2eproto.base,}};

static void InitDefaultsSCAMPTileInfo_scamp_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SCAMPProto::_SCAMPTileInfo_default_instance_;
    new (ptr) ::SCAMPProto::SCAMPTileInfo();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SCAMPProto::SCAMPTileInfo::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_SCAMPTileInfo_scamp_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsSCAMPTileInfo_scamp_2eproto}, {}};

static void InitDefaultsSCAMPArgs_scamp_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SCAMPProto::_SCAMPArgs_default_instance_;
    new (ptr) ::SCAMPProto::SCAMPArgs();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SCAMPProto::SCAMPArgs::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_SCAMPArgs_scamp_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsSCAMPArgs_scamp_2eproto}, {
      &scc_info_Profile_scamp_2eproto.base,}};

void InitDefaults_scamp_2eproto() {
  ::google::protobuf::internal::InitSCC(&scc_info_SCAMPWork_scamp_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_SCAMPStatus_scamp_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_SCAMPJobID_scamp_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_SCAMPRequest_scamp_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_SCAMPResult_scamp_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_RepeatedUInt_scamp_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_RepeatedULong_scamp_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_RepeatedFloat_scamp_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_RepeatedDouble_scamp_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ProfileData_scamp_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Profile_scamp_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_SCAMPTileInfo_scamp_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_SCAMPArgs_scamp_2eproto.base);
}

::google::protobuf::Metadata file_level_metadata_scamp_2eproto[13];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors_scamp_2eproto[3];
constexpr ::google::protobuf::ServiceDescriptor const** file_level_service_descriptors_scamp_2eproto = nullptr;

const ::google::protobuf::uint32 TableStruct_scamp_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPWork, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPWork, args_),
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPWork, valid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPStatus, job_id_),
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPStatus, status_),
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPStatus, progress_),
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPStatus, time_elapsed_),
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPStatus, eta_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPJobID, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPJobID, job_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPRequest, expected_throughput_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::RepeatedUInt, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::RepeatedUInt, value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::RepeatedULong, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::RepeatedULong, value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::RepeatedFloat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::RepeatedFloat, value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::RepeatedDouble, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::RepeatedDouble, value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::ProfileData, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::ProfileData, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  offsetof(::SCAMPProto::ProfileDataDefaultTypeInternal, uint32_value_),
  offsetof(::SCAMPProto::ProfileDataDefaultTypeInternal, uint64_value_),
  offsetof(::SCAMPProto::ProfileDataDefaultTypeInternal, float_value_),
  offsetof(::SCAMPProto::ProfileDataDefaultTypeInternal, double_value_),
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::ProfileData, Data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::Profile, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::Profile, data_),
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::Profile, type_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPTileInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPArgs, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPArgs, timeseries_a_),
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPArgs, timeseries_b_),
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPArgs, profile_a_),
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPArgs, profile_b_),
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPArgs, has_b_),
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPArgs, window_),
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPArgs, max_tile_size_),
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPArgs, distributed_start_row_),
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPArgs, distributed_start_col_),
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPArgs, distance_threshold_),
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPArgs, precision_type_),
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPArgs, profile_type_),
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPArgs, computing_rows_),
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPArgs, computing_columns_),
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPArgs, keep_rows_separate_),
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPArgs, is_aligned_),
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPArgs, timeseries_size_a_),
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPArgs, timeseries_size_b_),
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPArgs, job_id_),
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPArgs, tile_id_),
  PROTOBUF_FIELD_OFFSET(::SCAMPProto::SCAMPArgs, distributed_tile_size_),
};
static const ::google::protobuf::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, sizeof(::SCAMPProto::SCAMPWork)},
  { 7, -1, sizeof(::SCAMPProto::SCAMPStatus)},
  { 17, -1, sizeof(::SCAMPProto::SCAMPJobID)},
  { 23, -1, sizeof(::SCAMPProto::SCAMPRequest)},
  { 29, -1, sizeof(::SCAMPProto::SCAMPResult)},
  { 34, -1, sizeof(::SCAMPProto::RepeatedUInt)},
  { 40, -1, sizeof(::SCAMPProto::RepeatedULong)},
  { 46, -1, sizeof(::SCAMPProto::RepeatedFloat)},
  { 52, -1, sizeof(::SCAMPProto::RepeatedDouble)},
  { 58, -1, sizeof(::SCAMPProto::ProfileData)},
  { 68, -1, sizeof(::SCAMPProto::Profile)},
  { 75, -1, sizeof(::SCAMPProto::SCAMPTileInfo)},
  { 80, -1, sizeof(::SCAMPProto::SCAMPArgs)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::SCAMPProto::_SCAMPWork_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::SCAMPProto::_SCAMPStatus_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::SCAMPProto::_SCAMPJobID_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::SCAMPProto::_SCAMPRequest_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::SCAMPProto::_SCAMPResult_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::SCAMPProto::_RepeatedUInt_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::SCAMPProto::_RepeatedULong_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::SCAMPProto::_RepeatedFloat_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::SCAMPProto::_RepeatedDouble_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::SCAMPProto::_ProfileData_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::SCAMPProto::_Profile_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::SCAMPProto::_SCAMPTileInfo_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::SCAMPProto::_SCAMPArgs_default_instance_),
};

::google::protobuf::internal::AssignDescriptorsTable assign_descriptors_table_scamp_2eproto = {
  {}, AddDescriptors_scamp_2eproto, "scamp.proto", schemas,
  file_default_instances, TableStruct_scamp_2eproto::offsets,
  file_level_metadata_scamp_2eproto, 13, file_level_enum_descriptors_scamp_2eproto, file_level_service_descriptors_scamp_2eproto,
};

const char descriptor_table_protodef_scamp_2eproto[] =
  "\n\013scamp.proto\022\nSCAMPProto\"\?\n\tSCAMPWork\022#"
  "\n\004args\030\001 \001(\0132\025.SCAMPProto.SCAMPArgs\022\r\n\005v"
  "alid\030\002 \001(\010\"y\n\013SCAMPStatus\022\016\n\006job_id\030\001 \001("
  "\003\022%\n\006status\030\002 \001(\0162\025.SCAMPProto.JobStatus"
  "\022\020\n\010progress\030\003 \001(\002\022\024\n\014time_elapsed\030\004 \001(\003"
  "\022\013\n\003eta\030\005 \001(\003\"\034\n\nSCAMPJobID\022\016\n\006job_id\030\001 "
  "\001(\004\"+\n\014SCAMPRequest\022\033\n\023expected_throughp"
  "ut\030\001 \001(\003\"\r\n\013SCAMPResult\"\035\n\014RepeatedUInt\022"
  "\r\n\005value\030\001 \003(\r\"\036\n\rRepeatedULong\022\r\n\005value"
  "\030\001 \003(\004\"\036\n\rRepeatedFloat\022\r\n\005value\030\001 \003(\002\"\037"
  "\n\016RepeatedDouble\022\r\n\005value\030\001 \003(\001\"\340\001\n\013Prof"
  "ileData\0220\n\014uint32_value\030\001 \001(\0132\030.SCAMPPro"
  "to.RepeatedUIntH\000\0221\n\014uint64_value\030\002 \001(\0132"
  "\031.SCAMPProto.RepeatedULongH\000\0220\n\013float_va"
  "lue\030\003 \001(\0132\031.SCAMPProto.RepeatedFloatH\000\0222"
  "\n\014double_value\030\004 \001(\0132\032.SCAMPProto.Repeat"
  "edDoubleH\000B\006\n\004Data\"\\\n\007Profile\022%\n\004data\030\001 "
  "\003(\0132\027.SCAMPProto.ProfileData\022*\n\004type\030\002 \001"
  "(\0162\034.SCAMPProto.SCAMPProfileType\"\017\n\rSCAM"
  "PTileInfo\"\334\004\n\tSCAMPArgs\022\024\n\014timeseries_a\030"
  "\001 \003(\001\022\024\n\014timeseries_b\030\002 \003(\001\022&\n\tprofile_a"
  "\030\003 \001(\0132\023.SCAMPProto.Profile\022&\n\tprofile_b"
  "\030\004 \001(\0132\023.SCAMPProto.Profile\022\r\n\005has_b\030\005 \001"
  "(\010\022\016\n\006window\030\006 \001(\004\022\025\n\rmax_tile_size\030\007 \001("
  "\004\022\035\n\025distributed_start_row\030\010 \001(\003\022\035\n\025dist"
  "ributed_start_col\030\t \001(\003\022\032\n\022distance_thre"
  "shold\030\n \001(\001\0226\n\016precision_type\030\013 \001(\0162\036.SC"
  "AMPProto.SCAMPPrecisionType\0222\n\014profile_t"
  "ype\030\014 \001(\0162\034.SCAMPProto.SCAMPProfileType\022"
  "\026\n\016computing_rows\030\r \001(\010\022\031\n\021computing_col"
  "umns\030\016 \001(\010\022\032\n\022keep_rows_separate\030\017 \001(\010\022\022"
  "\n\nis_aligned\030\020 \001(\010\022\031\n\021timeseries_size_a\030"
  "\021 \001(\003\022\031\n\021timeseries_size_b\030\022 \001(\003\022\016\n\006job_"
  "id\030\023 \001(\003\022\017\n\007tile_id\030\024 \001(\003\022\035\n\025distributed"
  "_tile_size\030\025 \001(\003*\201\001\n\tJobStatus\022\026\n\022JOB_ST"
  "ATUS_INVALID\020\000\022\024\n\020JOB_STATUS_READY\020\001\022\026\n\022"
  "JOB_STATUS_RUNNING\020\002\022\027\n\023JOB_STATUS_FINIS"
  "HED\020\003\022\025\n\021JOB_STATUS_FAILED\020\004*\323\001\n\020SCAMPPr"
  "ofileType\022\030\n\024PROFILE_TYPE_INVALID\020\000\022\032\n\026P"
  "ROFILE_TYPE_1NN_INDEX\020\001\022\033\n\027PROFILE_TYPE_"
  "SUM_THRESH\020\002\022!\n\035PROFILE_TYPE_FREQUENCY_T"
  "HRESH\020\003\022\024\n\020PROFILE_TYPE_KNN\020\004\022\035\n\031PROFILE"
  "_TYPE_1NN_MULTIDIM\020\005\022\024\n\020PROFILE_TYPE_1NN"
  "\020\006*l\n\022SCAMPPrecisionType\022\025\n\021PRECISION_IN"
  "VALID\020\000\022\024\n\020PRECISION_SINGLE\020\001\022\023\n\017PRECISI"
  "ON_MIXED\020\002\022\024\n\020PRECISION_DOUBLE\020\0032\250\003\n\014SCA"
  "MPService\022E\n\020RequestSCAMPWork\022\030.SCAMPPro"
  "to.SCAMPRequest\032\025.SCAMPProto.SCAMPWork\"\000"
  "\022A\n\rSCAMPCombiner\022\025.SCAMPProto.SCAMPArgs"
  "\032\027.SCAMPProto.SCAMPResult\"\000\022E\n\021ReportTil"
  "eFailure\022\025.SCAMPProto.SCAMPArgs\032\027.SCAMPP"
  "roto.SCAMPResult\"\000\022\?\n\013IssueNewJob\022\025.SCAM"
  "PProto.SCAMPArgs\032\027.SCAMPProto.SCAMPStatu"
  "s\"\000\022C\n\016CheckJobStatus\022\026.SCAMPProto.SCAMP"
  "JobID\032\027.SCAMPProto.SCAMPStatus\"\000\022A\n\016Fetc"
  "hJobResult\022\026.SCAMPProto.SCAMPJobID\032\025.SCA"
  "MPProto.SCAMPWork\"\000b\006proto3"
  ;
::google::protobuf::internal::DescriptorTable descriptor_table_scamp_2eproto = {
  false, InitDefaults_scamp_2eproto, 
  descriptor_table_protodef_scamp_2eproto,
  "scamp.proto", &assign_descriptors_table_scamp_2eproto, 2267,
};

void AddDescriptors_scamp_2eproto() {
  static constexpr ::google::protobuf::internal::InitFunc deps[1] =
  {
  };
 ::google::protobuf::internal::AddDescriptors(&descriptor_table_scamp_2eproto, deps, 0);
}

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_scamp_2eproto = []() { AddDescriptors_scamp_2eproto(); return true; }();
namespace SCAMPProto {
const ::google::protobuf::EnumDescriptor* JobStatus_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_scamp_2eproto);
  return file_level_enum_descriptors_scamp_2eproto[0];
}
bool JobStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* SCAMPProfileType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_scamp_2eproto);
  return file_level_enum_descriptors_scamp_2eproto[1];
}
bool SCAMPProfileType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* SCAMPPrecisionType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_scamp_2eproto);
  return file_level_enum_descriptors_scamp_2eproto[2];
}
bool SCAMPPrecisionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void SCAMPWork::InitAsDefaultInstance() {
  ::SCAMPProto::_SCAMPWork_default_instance_._instance.get_mutable()->args_ = const_cast< ::SCAMPProto::SCAMPArgs*>(
      ::SCAMPProto::SCAMPArgs::internal_default_instance());
}
class SCAMPWork::HasBitSetters {
 public:
  static const ::SCAMPProto::SCAMPArgs& args(const SCAMPWork* msg);
};

const ::SCAMPProto::SCAMPArgs&
SCAMPWork::HasBitSetters::args(const SCAMPWork* msg) {
  return *msg->args_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SCAMPWork::kArgsFieldNumber;
const int SCAMPWork::kValidFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SCAMPWork::SCAMPWork()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SCAMPProto.SCAMPWork)
}
SCAMPWork::SCAMPWork(const SCAMPWork& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_args()) {
    args_ = new ::SCAMPProto::SCAMPArgs(*from.args_);
  } else {
    args_ = nullptr;
  }
  valid_ = from.valid_;
  // @@protoc_insertion_point(copy_constructor:SCAMPProto.SCAMPWork)
}

void SCAMPWork::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_SCAMPWork_scamp_2eproto.base);
  ::memset(&args_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&valid_) -
      reinterpret_cast<char*>(&args_)) + sizeof(valid_));
}

SCAMPWork::~SCAMPWork() {
  // @@protoc_insertion_point(destructor:SCAMPProto.SCAMPWork)
  SharedDtor();
}

void SCAMPWork::SharedDtor() {
  if (this != internal_default_instance()) delete args_;
}

void SCAMPWork::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SCAMPWork& SCAMPWork::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_SCAMPWork_scamp_2eproto.base);
  return *internal_default_instance();
}


void SCAMPWork::Clear() {
// @@protoc_insertion_point(message_clear_start:SCAMPProto.SCAMPWork)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == nullptr && args_ != nullptr) {
    delete args_;
  }
  args_ = nullptr;
  valid_ = false;
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SCAMPWork::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<SCAMPWork*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // .SCAMPProto.SCAMPArgs args = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::SCAMPProto::SCAMPArgs::_InternalParse;
        object = msg->mutable_args();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // bool valid = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_valid(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SCAMPWork::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SCAMPProto.SCAMPWork)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .SCAMPProto.SCAMPArgs args = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_args()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool valid = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &valid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SCAMPProto.SCAMPWork)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SCAMPProto.SCAMPWork)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SCAMPWork::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SCAMPProto.SCAMPWork)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .SCAMPProto.SCAMPArgs args = 1;
  if (this->has_args()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::args(this), output);
  }

  // bool valid = 2;
  if (this->valid() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->valid(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SCAMPProto.SCAMPWork)
}

::google::protobuf::uint8* SCAMPWork::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SCAMPProto.SCAMPWork)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .SCAMPProto.SCAMPArgs args = 1;
  if (this->has_args()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::args(this), target);
  }

  // bool valid = 2;
  if (this->valid() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->valid(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SCAMPProto.SCAMPWork)
  return target;
}

size_t SCAMPWork::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SCAMPProto.SCAMPWork)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .SCAMPProto.SCAMPArgs args = 1;
  if (this->has_args()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *args_);
  }

  // bool valid = 2;
  if (this->valid() != 0) {
    total_size += 1 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SCAMPWork::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SCAMPProto.SCAMPWork)
  GOOGLE_DCHECK_NE(&from, this);
  const SCAMPWork* source =
      ::google::protobuf::DynamicCastToGenerated<SCAMPWork>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SCAMPProto.SCAMPWork)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SCAMPProto.SCAMPWork)
    MergeFrom(*source);
  }
}

void SCAMPWork::MergeFrom(const SCAMPWork& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SCAMPProto.SCAMPWork)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_args()) {
    mutable_args()->::SCAMPProto::SCAMPArgs::MergeFrom(from.args());
  }
  if (from.valid() != 0) {
    set_valid(from.valid());
  }
}

void SCAMPWork::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SCAMPProto.SCAMPWork)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SCAMPWork::CopyFrom(const SCAMPWork& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SCAMPProto.SCAMPWork)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SCAMPWork::IsInitialized() const {
  return true;
}

void SCAMPWork::Swap(SCAMPWork* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SCAMPWork::InternalSwap(SCAMPWork* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(args_, other->args_);
  swap(valid_, other->valid_);
}

::google::protobuf::Metadata SCAMPWork::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_scamp_2eproto);
  return ::file_level_metadata_scamp_2eproto[kIndexInFileMessages];
}


// ===================================================================

void SCAMPStatus::InitAsDefaultInstance() {
}
class SCAMPStatus::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SCAMPStatus::kJobIdFieldNumber;
const int SCAMPStatus::kStatusFieldNumber;
const int SCAMPStatus::kProgressFieldNumber;
const int SCAMPStatus::kTimeElapsedFieldNumber;
const int SCAMPStatus::kEtaFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SCAMPStatus::SCAMPStatus()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SCAMPProto.SCAMPStatus)
}
SCAMPStatus::SCAMPStatus(const SCAMPStatus& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&job_id_, &from.job_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&eta_) -
    reinterpret_cast<char*>(&job_id_)) + sizeof(eta_));
  // @@protoc_insertion_point(copy_constructor:SCAMPProto.SCAMPStatus)
}

void SCAMPStatus::SharedCtor() {
  ::memset(&job_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&eta_) -
      reinterpret_cast<char*>(&job_id_)) + sizeof(eta_));
}

SCAMPStatus::~SCAMPStatus() {
  // @@protoc_insertion_point(destructor:SCAMPProto.SCAMPStatus)
  SharedDtor();
}

void SCAMPStatus::SharedDtor() {
}

void SCAMPStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SCAMPStatus& SCAMPStatus::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_SCAMPStatus_scamp_2eproto.base);
  return *internal_default_instance();
}


void SCAMPStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:SCAMPProto.SCAMPStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&job_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&eta_) -
      reinterpret_cast<char*>(&job_id_)) + sizeof(eta_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SCAMPStatus::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<SCAMPStatus*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // int64 job_id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_job_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // .SCAMPProto.JobStatus status = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        msg->set_status(static_cast<::SCAMPProto::JobStatus>(val));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // float progress = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 29) goto handle_unusual;
        msg->set_progress(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // int64 time_elapsed = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_time_elapsed(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // int64 eta = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        msg->set_eta(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SCAMPStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SCAMPProto.SCAMPStatus)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // int64 job_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &job_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .SCAMPProto.JobStatus status = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_status(static_cast< ::SCAMPProto::JobStatus >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float progress = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (29 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &progress_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int64 time_elapsed = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &time_elapsed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int64 eta = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &eta_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SCAMPProto.SCAMPStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SCAMPProto.SCAMPStatus)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SCAMPStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SCAMPProto.SCAMPStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 job_id = 1;
  if (this->job_id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->job_id(), output);
  }

  // .SCAMPProto.JobStatus status = 2;
  if (this->status() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->status(), output);
  }

  // float progress = 3;
  if (this->progress() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->progress(), output);
  }

  // int64 time_elapsed = 4;
  if (this->time_elapsed() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->time_elapsed(), output);
  }

  // int64 eta = 5;
  if (this->eta() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->eta(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SCAMPProto.SCAMPStatus)
}

::google::protobuf::uint8* SCAMPStatus::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SCAMPProto.SCAMPStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 job_id = 1;
  if (this->job_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->job_id(), target);
  }

  // .SCAMPProto.JobStatus status = 2;
  if (this->status() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->status(), target);
  }

  // float progress = 3;
  if (this->progress() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->progress(), target);
  }

  // int64 time_elapsed = 4;
  if (this->time_elapsed() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(4, this->time_elapsed(), target);
  }

  // int64 eta = 5;
  if (this->eta() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(5, this->eta(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SCAMPProto.SCAMPStatus)
  return target;
}

size_t SCAMPStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SCAMPProto.SCAMPStatus)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 job_id = 1;
  if (this->job_id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->job_id());
  }

  // .SCAMPProto.JobStatus status = 2;
  if (this->status() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
  }

  // float progress = 3;
  if (this->progress() != 0) {
    total_size += 1 + 4;
  }

  // int64 time_elapsed = 4;
  if (this->time_elapsed() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->time_elapsed());
  }

  // int64 eta = 5;
  if (this->eta() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->eta());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SCAMPStatus::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SCAMPProto.SCAMPStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const SCAMPStatus* source =
      ::google::protobuf::DynamicCastToGenerated<SCAMPStatus>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SCAMPProto.SCAMPStatus)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SCAMPProto.SCAMPStatus)
    MergeFrom(*source);
  }
}

void SCAMPStatus::MergeFrom(const SCAMPStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SCAMPProto.SCAMPStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.job_id() != 0) {
    set_job_id(from.job_id());
  }
  if (from.status() != 0) {
    set_status(from.status());
  }
  if (from.progress() != 0) {
    set_progress(from.progress());
  }
  if (from.time_elapsed() != 0) {
    set_time_elapsed(from.time_elapsed());
  }
  if (from.eta() != 0) {
    set_eta(from.eta());
  }
}

void SCAMPStatus::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SCAMPProto.SCAMPStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SCAMPStatus::CopyFrom(const SCAMPStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SCAMPProto.SCAMPStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SCAMPStatus::IsInitialized() const {
  return true;
}

void SCAMPStatus::Swap(SCAMPStatus* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SCAMPStatus::InternalSwap(SCAMPStatus* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(job_id_, other->job_id_);
  swap(status_, other->status_);
  swap(progress_, other->progress_);
  swap(time_elapsed_, other->time_elapsed_);
  swap(eta_, other->eta_);
}

::google::protobuf::Metadata SCAMPStatus::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_scamp_2eproto);
  return ::file_level_metadata_scamp_2eproto[kIndexInFileMessages];
}


// ===================================================================

void SCAMPJobID::InitAsDefaultInstance() {
}
class SCAMPJobID::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SCAMPJobID::kJobIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SCAMPJobID::SCAMPJobID()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SCAMPProto.SCAMPJobID)
}
SCAMPJobID::SCAMPJobID(const SCAMPJobID& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  job_id_ = from.job_id_;
  // @@protoc_insertion_point(copy_constructor:SCAMPProto.SCAMPJobID)
}

void SCAMPJobID::SharedCtor() {
  job_id_ = PROTOBUF_ULONGLONG(0);
}

SCAMPJobID::~SCAMPJobID() {
  // @@protoc_insertion_point(destructor:SCAMPProto.SCAMPJobID)
  SharedDtor();
}

void SCAMPJobID::SharedDtor() {
}

void SCAMPJobID::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SCAMPJobID& SCAMPJobID::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_SCAMPJobID_scamp_2eproto.base);
  return *internal_default_instance();
}


void SCAMPJobID::Clear() {
// @@protoc_insertion_point(message_clear_start:SCAMPProto.SCAMPJobID)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  job_id_ = PROTOBUF_ULONGLONG(0);
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SCAMPJobID::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<SCAMPJobID*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // uint64 job_id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_job_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SCAMPJobID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SCAMPProto.SCAMPJobID)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // uint64 job_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &job_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SCAMPProto.SCAMPJobID)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SCAMPProto.SCAMPJobID)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SCAMPJobID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SCAMPProto.SCAMPJobID)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 job_id = 1;
  if (this->job_id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->job_id(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SCAMPProto.SCAMPJobID)
}

::google::protobuf::uint8* SCAMPJobID::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SCAMPProto.SCAMPJobID)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 job_id = 1;
  if (this->job_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->job_id(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SCAMPProto.SCAMPJobID)
  return target;
}

size_t SCAMPJobID::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SCAMPProto.SCAMPJobID)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 job_id = 1;
  if (this->job_id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->job_id());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SCAMPJobID::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SCAMPProto.SCAMPJobID)
  GOOGLE_DCHECK_NE(&from, this);
  const SCAMPJobID* source =
      ::google::protobuf::DynamicCastToGenerated<SCAMPJobID>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SCAMPProto.SCAMPJobID)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SCAMPProto.SCAMPJobID)
    MergeFrom(*source);
  }
}

void SCAMPJobID::MergeFrom(const SCAMPJobID& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SCAMPProto.SCAMPJobID)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.job_id() != 0) {
    set_job_id(from.job_id());
  }
}

void SCAMPJobID::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SCAMPProto.SCAMPJobID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SCAMPJobID::CopyFrom(const SCAMPJobID& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SCAMPProto.SCAMPJobID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SCAMPJobID::IsInitialized() const {
  return true;
}

void SCAMPJobID::Swap(SCAMPJobID* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SCAMPJobID::InternalSwap(SCAMPJobID* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(job_id_, other->job_id_);
}

::google::protobuf::Metadata SCAMPJobID::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_scamp_2eproto);
  return ::file_level_metadata_scamp_2eproto[kIndexInFileMessages];
}


// ===================================================================

void SCAMPRequest::InitAsDefaultInstance() {
}
class SCAMPRequest::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SCAMPRequest::kExpectedThroughputFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SCAMPRequest::SCAMPRequest()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SCAMPProto.SCAMPRequest)
}
SCAMPRequest::SCAMPRequest(const SCAMPRequest& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  expected_throughput_ = from.expected_throughput_;
  // @@protoc_insertion_point(copy_constructor:SCAMPProto.SCAMPRequest)
}

void SCAMPRequest::SharedCtor() {
  expected_throughput_ = PROTOBUF_LONGLONG(0);
}

SCAMPRequest::~SCAMPRequest() {
  // @@protoc_insertion_point(destructor:SCAMPProto.SCAMPRequest)
  SharedDtor();
}

void SCAMPRequest::SharedDtor() {
}

void SCAMPRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SCAMPRequest& SCAMPRequest::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_SCAMPRequest_scamp_2eproto.base);
  return *internal_default_instance();
}


void SCAMPRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:SCAMPProto.SCAMPRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  expected_throughput_ = PROTOBUF_LONGLONG(0);
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SCAMPRequest::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<SCAMPRequest*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // int64 expected_throughput = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_expected_throughput(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SCAMPRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SCAMPProto.SCAMPRequest)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // int64 expected_throughput = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &expected_throughput_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SCAMPProto.SCAMPRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SCAMPProto.SCAMPRequest)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SCAMPRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SCAMPProto.SCAMPRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 expected_throughput = 1;
  if (this->expected_throughput() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->expected_throughput(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SCAMPProto.SCAMPRequest)
}

::google::protobuf::uint8* SCAMPRequest::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SCAMPProto.SCAMPRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 expected_throughput = 1;
  if (this->expected_throughput() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->expected_throughput(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SCAMPProto.SCAMPRequest)
  return target;
}

size_t SCAMPRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SCAMPProto.SCAMPRequest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 expected_throughput = 1;
  if (this->expected_throughput() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->expected_throughput());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SCAMPRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SCAMPProto.SCAMPRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const SCAMPRequest* source =
      ::google::protobuf::DynamicCastToGenerated<SCAMPRequest>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SCAMPProto.SCAMPRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SCAMPProto.SCAMPRequest)
    MergeFrom(*source);
  }
}

void SCAMPRequest::MergeFrom(const SCAMPRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SCAMPProto.SCAMPRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.expected_throughput() != 0) {
    set_expected_throughput(from.expected_throughput());
  }
}

void SCAMPRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SCAMPProto.SCAMPRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SCAMPRequest::CopyFrom(const SCAMPRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SCAMPProto.SCAMPRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SCAMPRequest::IsInitialized() const {
  return true;
}

void SCAMPRequest::Swap(SCAMPRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SCAMPRequest::InternalSwap(SCAMPRequest* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(expected_throughput_, other->expected_throughput_);
}

::google::protobuf::Metadata SCAMPRequest::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_scamp_2eproto);
  return ::file_level_metadata_scamp_2eproto[kIndexInFileMessages];
}


// ===================================================================

void SCAMPResult::InitAsDefaultInstance() {
}
class SCAMPResult::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SCAMPResult::SCAMPResult()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SCAMPProto.SCAMPResult)
}
SCAMPResult::SCAMPResult(const SCAMPResult& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:SCAMPProto.SCAMPResult)
}

void SCAMPResult::SharedCtor() {
}

SCAMPResult::~SCAMPResult() {
  // @@protoc_insertion_point(destructor:SCAMPProto.SCAMPResult)
  SharedDtor();
}

void SCAMPResult::SharedDtor() {
}

void SCAMPResult::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SCAMPResult& SCAMPResult::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_SCAMPResult_scamp_2eproto.base);
  return *internal_default_instance();
}


void SCAMPResult::Clear() {
// @@protoc_insertion_point(message_clear_start:SCAMPProto.SCAMPResult)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SCAMPResult::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<SCAMPResult*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      default: {
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SCAMPResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SCAMPProto.SCAMPResult)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, _internal_metadata_.mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:SCAMPProto.SCAMPResult)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SCAMPProto.SCAMPResult)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SCAMPResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SCAMPProto.SCAMPResult)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SCAMPProto.SCAMPResult)
}

::google::protobuf::uint8* SCAMPResult::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SCAMPProto.SCAMPResult)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SCAMPProto.SCAMPResult)
  return target;
}

size_t SCAMPResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SCAMPProto.SCAMPResult)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SCAMPResult::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SCAMPProto.SCAMPResult)
  GOOGLE_DCHECK_NE(&from, this);
  const SCAMPResult* source =
      ::google::protobuf::DynamicCastToGenerated<SCAMPResult>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SCAMPProto.SCAMPResult)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SCAMPProto.SCAMPResult)
    MergeFrom(*source);
  }
}

void SCAMPResult::MergeFrom(const SCAMPResult& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SCAMPProto.SCAMPResult)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void SCAMPResult::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SCAMPProto.SCAMPResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SCAMPResult::CopyFrom(const SCAMPResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SCAMPProto.SCAMPResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SCAMPResult::IsInitialized() const {
  return true;
}

void SCAMPResult::Swap(SCAMPResult* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SCAMPResult::InternalSwap(SCAMPResult* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata SCAMPResult::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_scamp_2eproto);
  return ::file_level_metadata_scamp_2eproto[kIndexInFileMessages];
}


// ===================================================================

void RepeatedUInt::InitAsDefaultInstance() {
}
class RepeatedUInt::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RepeatedUInt::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RepeatedUInt::RepeatedUInt()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SCAMPProto.RepeatedUInt)
}
RepeatedUInt::RepeatedUInt(const RepeatedUInt& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      value_(from.value_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:SCAMPProto.RepeatedUInt)
}

void RepeatedUInt::SharedCtor() {
}

RepeatedUInt::~RepeatedUInt() {
  // @@protoc_insertion_point(destructor:SCAMPProto.RepeatedUInt)
  SharedDtor();
}

void RepeatedUInt::SharedDtor() {
}

void RepeatedUInt::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RepeatedUInt& RepeatedUInt::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_RepeatedUInt_scamp_2eproto.base);
  return *internal_default_instance();
}


void RepeatedUInt::Clear() {
// @@protoc_insertion_point(message_clear_start:SCAMPProto.RepeatedUInt)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  value_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* RepeatedUInt::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<RepeatedUInt*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated uint32 value = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) == 10) {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::google::protobuf::internal::PackedUInt32Parser;
          object = msg->mutable_value();
          if (size > end - ptr) goto len_delim_till_end;
          auto newend = ptr + size;
          if (size) ptr = parser_till_end(ptr, newend, object, ctx);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        do {
          msg->add_value(::google::protobuf::internal::ReadVarint(&ptr));
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 8 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool RepeatedUInt::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SCAMPProto.RepeatedUInt)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 value = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_value())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 10u, input, this->mutable_value())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SCAMPProto.RepeatedUInt)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SCAMPProto.RepeatedUInt)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void RepeatedUInt::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SCAMPProto.RepeatedUInt)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 value = 1;
  if (this->value_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_value_cached_byte_size_.load(
        std::memory_order_relaxed));
  }
  for (int i = 0, n = this->value_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->value(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SCAMPProto.RepeatedUInt)
}

::google::protobuf::uint8* RepeatedUInt::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SCAMPProto.RepeatedUInt)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 value = 1;
  if (this->value_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      1,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
        _value_cached_byte_size_.load(std::memory_order_relaxed),
         target);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32NoTagToArray(this->value_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SCAMPProto.RepeatedUInt)
  return target;
}

size_t RepeatedUInt::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SCAMPProto.RepeatedUInt)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 value = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->value_);
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
            static_cast<::google::protobuf::int32>(data_size));
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    _value_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RepeatedUInt::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SCAMPProto.RepeatedUInt)
  GOOGLE_DCHECK_NE(&from, this);
  const RepeatedUInt* source =
      ::google::protobuf::DynamicCastToGenerated<RepeatedUInt>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SCAMPProto.RepeatedUInt)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SCAMPProto.RepeatedUInt)
    MergeFrom(*source);
  }
}

void RepeatedUInt::MergeFrom(const RepeatedUInt& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SCAMPProto.RepeatedUInt)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  value_.MergeFrom(from.value_);
}

void RepeatedUInt::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SCAMPProto.RepeatedUInt)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RepeatedUInt::CopyFrom(const RepeatedUInt& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SCAMPProto.RepeatedUInt)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RepeatedUInt::IsInitialized() const {
  return true;
}

void RepeatedUInt::Swap(RepeatedUInt* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RepeatedUInt::InternalSwap(RepeatedUInt* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  value_.InternalSwap(&other->value_);
}

::google::protobuf::Metadata RepeatedUInt::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_scamp_2eproto);
  return ::file_level_metadata_scamp_2eproto[kIndexInFileMessages];
}


// ===================================================================

void RepeatedULong::InitAsDefaultInstance() {
}
class RepeatedULong::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RepeatedULong::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RepeatedULong::RepeatedULong()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SCAMPProto.RepeatedULong)
}
RepeatedULong::RepeatedULong(const RepeatedULong& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      value_(from.value_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:SCAMPProto.RepeatedULong)
}

void RepeatedULong::SharedCtor() {
}

RepeatedULong::~RepeatedULong() {
  // @@protoc_insertion_point(destructor:SCAMPProto.RepeatedULong)
  SharedDtor();
}

void RepeatedULong::SharedDtor() {
}

void RepeatedULong::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RepeatedULong& RepeatedULong::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_RepeatedULong_scamp_2eproto.base);
  return *internal_default_instance();
}


void RepeatedULong::Clear() {
// @@protoc_insertion_point(message_clear_start:SCAMPProto.RepeatedULong)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  value_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* RepeatedULong::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<RepeatedULong*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated uint64 value = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) == 10) {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::google::protobuf::internal::PackedUInt64Parser;
          object = msg->mutable_value();
          if (size > end - ptr) goto len_delim_till_end;
          auto newend = ptr + size;
          if (size) ptr = parser_till_end(ptr, newend, object, ctx);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        do {
          msg->add_value(::google::protobuf::internal::ReadVarint(&ptr));
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 8 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool RepeatedULong::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SCAMPProto.RepeatedULong)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint64 value = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_value())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 10u, input, this->mutable_value())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SCAMPProto.RepeatedULong)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SCAMPProto.RepeatedULong)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void RepeatedULong::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SCAMPProto.RepeatedULong)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 value = 1;
  if (this->value_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_value_cached_byte_size_.load(
        std::memory_order_relaxed));
  }
  for (int i = 0, n = this->value_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64NoTag(
      this->value(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SCAMPProto.RepeatedULong)
}

::google::protobuf::uint8* RepeatedULong::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SCAMPProto.RepeatedULong)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 value = 1;
  if (this->value_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      1,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
        _value_cached_byte_size_.load(std::memory_order_relaxed),
         target);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt64NoTagToArray(this->value_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SCAMPProto.RepeatedULong)
  return target;
}

size_t RepeatedULong::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SCAMPProto.RepeatedULong)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 value = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt64Size(this->value_);
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
            static_cast<::google::protobuf::int32>(data_size));
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    _value_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RepeatedULong::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SCAMPProto.RepeatedULong)
  GOOGLE_DCHECK_NE(&from, this);
  const RepeatedULong* source =
      ::google::protobuf::DynamicCastToGenerated<RepeatedULong>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SCAMPProto.RepeatedULong)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SCAMPProto.RepeatedULong)
    MergeFrom(*source);
  }
}

void RepeatedULong::MergeFrom(const RepeatedULong& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SCAMPProto.RepeatedULong)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  value_.MergeFrom(from.value_);
}

void RepeatedULong::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SCAMPProto.RepeatedULong)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RepeatedULong::CopyFrom(const RepeatedULong& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SCAMPProto.RepeatedULong)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RepeatedULong::IsInitialized() const {
  return true;
}

void RepeatedULong::Swap(RepeatedULong* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RepeatedULong::InternalSwap(RepeatedULong* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  value_.InternalSwap(&other->value_);
}

::google::protobuf::Metadata RepeatedULong::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_scamp_2eproto);
  return ::file_level_metadata_scamp_2eproto[kIndexInFileMessages];
}


// ===================================================================

void RepeatedFloat::InitAsDefaultInstance() {
}
class RepeatedFloat::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RepeatedFloat::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RepeatedFloat::RepeatedFloat()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SCAMPProto.RepeatedFloat)
}
RepeatedFloat::RepeatedFloat(const RepeatedFloat& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      value_(from.value_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:SCAMPProto.RepeatedFloat)
}

void RepeatedFloat::SharedCtor() {
}

RepeatedFloat::~RepeatedFloat() {
  // @@protoc_insertion_point(destructor:SCAMPProto.RepeatedFloat)
  SharedDtor();
}

void RepeatedFloat::SharedDtor() {
}

void RepeatedFloat::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RepeatedFloat& RepeatedFloat::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_RepeatedFloat_scamp_2eproto.base);
  return *internal_default_instance();
}


void RepeatedFloat::Clear() {
// @@protoc_insertion_point(message_clear_start:SCAMPProto.RepeatedFloat)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  value_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* RepeatedFloat::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<RepeatedFloat*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated float value = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) == 10) {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::google::protobuf::internal::PackedFloatParser;
          object = msg->mutable_value();
          if (size > end - ptr) goto len_delim_till_end;
          auto newend = ptr + size;
          if (size) ptr = parser_till_end(ptr, newend, object, ctx);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 13) goto handle_unusual;
        do {
          msg->add_value(::google::protobuf::io::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 13 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool RepeatedFloat::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SCAMPProto.RepeatedFloat)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated float value = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_value())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (13 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 10u, input, this->mutable_value())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SCAMPProto.RepeatedFloat)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SCAMPProto.RepeatedFloat)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void RepeatedFloat::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SCAMPProto.RepeatedFloat)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float value = 1;
  if (this->value_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_value_cached_byte_size_.load(
        std::memory_order_relaxed));
    ::google::protobuf::internal::WireFormatLite::WriteFloatArray(
      this->value().data(), this->value_size(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SCAMPProto.RepeatedFloat)
}

::google::protobuf::uint8* RepeatedFloat::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SCAMPProto.RepeatedFloat)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float value = 1;
  if (this->value_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      1,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
        _value_cached_byte_size_.load(std::memory_order_relaxed),
         target);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatNoTagToArray(this->value_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SCAMPProto.RepeatedFloat)
  return target;
}

size_t RepeatedFloat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SCAMPProto.RepeatedFloat)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float value = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->value_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
            static_cast<::google::protobuf::int32>(data_size));
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    _value_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RepeatedFloat::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SCAMPProto.RepeatedFloat)
  GOOGLE_DCHECK_NE(&from, this);
  const RepeatedFloat* source =
      ::google::protobuf::DynamicCastToGenerated<RepeatedFloat>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SCAMPProto.RepeatedFloat)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SCAMPProto.RepeatedFloat)
    MergeFrom(*source);
  }
}

void RepeatedFloat::MergeFrom(const RepeatedFloat& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SCAMPProto.RepeatedFloat)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  value_.MergeFrom(from.value_);
}

void RepeatedFloat::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SCAMPProto.RepeatedFloat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RepeatedFloat::CopyFrom(const RepeatedFloat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SCAMPProto.RepeatedFloat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RepeatedFloat::IsInitialized() const {
  return true;
}

void RepeatedFloat::Swap(RepeatedFloat* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RepeatedFloat::InternalSwap(RepeatedFloat* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  value_.InternalSwap(&other->value_);
}

::google::protobuf::Metadata RepeatedFloat::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_scamp_2eproto);
  return ::file_level_metadata_scamp_2eproto[kIndexInFileMessages];
}


// ===================================================================

void RepeatedDouble::InitAsDefaultInstance() {
}
class RepeatedDouble::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RepeatedDouble::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RepeatedDouble::RepeatedDouble()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SCAMPProto.RepeatedDouble)
}
RepeatedDouble::RepeatedDouble(const RepeatedDouble& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      value_(from.value_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:SCAMPProto.RepeatedDouble)
}

void RepeatedDouble::SharedCtor() {
}

RepeatedDouble::~RepeatedDouble() {
  // @@protoc_insertion_point(destructor:SCAMPProto.RepeatedDouble)
  SharedDtor();
}

void RepeatedDouble::SharedDtor() {
}

void RepeatedDouble::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RepeatedDouble& RepeatedDouble::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_RepeatedDouble_scamp_2eproto.base);
  return *internal_default_instance();
}


void RepeatedDouble::Clear() {
// @@protoc_insertion_point(message_clear_start:SCAMPProto.RepeatedDouble)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  value_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* RepeatedDouble::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<RepeatedDouble*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated double value = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) == 10) {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::google::protobuf::internal::PackedDoubleParser;
          object = msg->mutable_value();
          if (size > end - ptr) goto len_delim_till_end;
          auto newend = ptr + size;
          if (size) ptr = parser_till_end(ptr, newend, object, ctx);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        do {
          msg->add_value(::google::protobuf::io::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 9 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool RepeatedDouble::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SCAMPProto.RepeatedDouble)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated double value = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_value())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 10u, input, this->mutable_value())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SCAMPProto.RepeatedDouble)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SCAMPProto.RepeatedDouble)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void RepeatedDouble::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SCAMPProto.RepeatedDouble)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double value = 1;
  if (this->value_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_value_cached_byte_size_.load(
        std::memory_order_relaxed));
    ::google::protobuf::internal::WireFormatLite::WriteDoubleArray(
      this->value().data(), this->value_size(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SCAMPProto.RepeatedDouble)
}

::google::protobuf::uint8* RepeatedDouble::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SCAMPProto.RepeatedDouble)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double value = 1;
  if (this->value_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      1,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
        _value_cached_byte_size_.load(std::memory_order_relaxed),
         target);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteDoubleNoTagToArray(this->value_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SCAMPProto.RepeatedDouble)
  return target;
}

size_t RepeatedDouble::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SCAMPProto.RepeatedDouble)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double value = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->value_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
            static_cast<::google::protobuf::int32>(data_size));
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    _value_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RepeatedDouble::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SCAMPProto.RepeatedDouble)
  GOOGLE_DCHECK_NE(&from, this);
  const RepeatedDouble* source =
      ::google::protobuf::DynamicCastToGenerated<RepeatedDouble>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SCAMPProto.RepeatedDouble)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SCAMPProto.RepeatedDouble)
    MergeFrom(*source);
  }
}

void RepeatedDouble::MergeFrom(const RepeatedDouble& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SCAMPProto.RepeatedDouble)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  value_.MergeFrom(from.value_);
}

void RepeatedDouble::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SCAMPProto.RepeatedDouble)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RepeatedDouble::CopyFrom(const RepeatedDouble& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SCAMPProto.RepeatedDouble)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RepeatedDouble::IsInitialized() const {
  return true;
}

void RepeatedDouble::Swap(RepeatedDouble* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RepeatedDouble::InternalSwap(RepeatedDouble* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  value_.InternalSwap(&other->value_);
}

::google::protobuf::Metadata RepeatedDouble::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_scamp_2eproto);
  return ::file_level_metadata_scamp_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ProfileData::InitAsDefaultInstance() {
  ::SCAMPProto::_ProfileData_default_instance_.uint32_value_ = const_cast< ::SCAMPProto::RepeatedUInt*>(
      ::SCAMPProto::RepeatedUInt::internal_default_instance());
  ::SCAMPProto::_ProfileData_default_instance_.uint64_value_ = const_cast< ::SCAMPProto::RepeatedULong*>(
      ::SCAMPProto::RepeatedULong::internal_default_instance());
  ::SCAMPProto::_ProfileData_default_instance_.float_value_ = const_cast< ::SCAMPProto::RepeatedFloat*>(
      ::SCAMPProto::RepeatedFloat::internal_default_instance());
  ::SCAMPProto::_ProfileData_default_instance_.double_value_ = const_cast< ::SCAMPProto::RepeatedDouble*>(
      ::SCAMPProto::RepeatedDouble::internal_default_instance());
}
class ProfileData::HasBitSetters {
 public:
  static const ::SCAMPProto::RepeatedUInt& uint32_value(const ProfileData* msg);
  static const ::SCAMPProto::RepeatedULong& uint64_value(const ProfileData* msg);
  static const ::SCAMPProto::RepeatedFloat& float_value(const ProfileData* msg);
  static const ::SCAMPProto::RepeatedDouble& double_value(const ProfileData* msg);
};

const ::SCAMPProto::RepeatedUInt&
ProfileData::HasBitSetters::uint32_value(const ProfileData* msg) {
  return *msg->Data_.uint32_value_;
}
const ::SCAMPProto::RepeatedULong&
ProfileData::HasBitSetters::uint64_value(const ProfileData* msg) {
  return *msg->Data_.uint64_value_;
}
const ::SCAMPProto::RepeatedFloat&
ProfileData::HasBitSetters::float_value(const ProfileData* msg) {
  return *msg->Data_.float_value_;
}
const ::SCAMPProto::RepeatedDouble&
ProfileData::HasBitSetters::double_value(const ProfileData* msg) {
  return *msg->Data_.double_value_;
}
void ProfileData::set_allocated_uint32_value(::SCAMPProto::RepeatedUInt* uint32_value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_Data();
  if (uint32_value) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      uint32_value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, uint32_value, submessage_arena);
    }
    set_has_uint32_value();
    Data_.uint32_value_ = uint32_value;
  }
  // @@protoc_insertion_point(field_set_allocated:SCAMPProto.ProfileData.uint32_value)
}
void ProfileData::set_allocated_uint64_value(::SCAMPProto::RepeatedULong* uint64_value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_Data();
  if (uint64_value) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      uint64_value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, uint64_value, submessage_arena);
    }
    set_has_uint64_value();
    Data_.uint64_value_ = uint64_value;
  }
  // @@protoc_insertion_point(field_set_allocated:SCAMPProto.ProfileData.uint64_value)
}
void ProfileData::set_allocated_float_value(::SCAMPProto::RepeatedFloat* float_value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_Data();
  if (float_value) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      float_value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, float_value, submessage_arena);
    }
    set_has_float_value();
    Data_.float_value_ = float_value;
  }
  // @@protoc_insertion_point(field_set_allocated:SCAMPProto.ProfileData.float_value)
}
void ProfileData::set_allocated_double_value(::SCAMPProto::RepeatedDouble* double_value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_Data();
  if (double_value) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      double_value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, double_value, submessage_arena);
    }
    set_has_double_value();
    Data_.double_value_ = double_value;
  }
  // @@protoc_insertion_point(field_set_allocated:SCAMPProto.ProfileData.double_value)
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ProfileData::kUint32ValueFieldNumber;
const int ProfileData::kUint64ValueFieldNumber;
const int ProfileData::kFloatValueFieldNumber;
const int ProfileData::kDoubleValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ProfileData::ProfileData()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SCAMPProto.ProfileData)
}
ProfileData::ProfileData(const ProfileData& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  clear_has_Data();
  switch (from.Data_case()) {
    case kUint32Value: {
      mutable_uint32_value()->::SCAMPProto::RepeatedUInt::MergeFrom(from.uint32_value());
      break;
    }
    case kUint64Value: {
      mutable_uint64_value()->::SCAMPProto::RepeatedULong::MergeFrom(from.uint64_value());
      break;
    }
    case kFloatValue: {
      mutable_float_value()->::SCAMPProto::RepeatedFloat::MergeFrom(from.float_value());
      break;
    }
    case kDoubleValue: {
      mutable_double_value()->::SCAMPProto::RepeatedDouble::MergeFrom(from.double_value());
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:SCAMPProto.ProfileData)
}

void ProfileData::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_ProfileData_scamp_2eproto.base);
  clear_has_Data();
}

ProfileData::~ProfileData() {
  // @@protoc_insertion_point(destructor:SCAMPProto.ProfileData)
  SharedDtor();
}

void ProfileData::SharedDtor() {
  if (has_Data()) {
    clear_Data();
  }
}

void ProfileData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ProfileData& ProfileData::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ProfileData_scamp_2eproto.base);
  return *internal_default_instance();
}


void ProfileData::clear_Data() {
// @@protoc_insertion_point(one_of_clear_start:SCAMPProto.ProfileData)
  switch (Data_case()) {
    case kUint32Value: {
      delete Data_.uint32_value_;
      break;
    }
    case kUint64Value: {
      delete Data_.uint64_value_;
      break;
    }
    case kFloatValue: {
      delete Data_.float_value_;
      break;
    }
    case kDoubleValue: {
      delete Data_.double_value_;
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = DATA_NOT_SET;
}


void ProfileData::Clear() {
// @@protoc_insertion_point(message_clear_start:SCAMPProto.ProfileData)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_Data();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ProfileData::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ProfileData*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // .SCAMPProto.RepeatedUInt uint32_value = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::SCAMPProto::RepeatedUInt::_InternalParse;
        object = msg->mutable_uint32_value();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // .SCAMPProto.RepeatedULong uint64_value = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::SCAMPProto::RepeatedULong::_InternalParse;
        object = msg->mutable_uint64_value();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // .SCAMPProto.RepeatedFloat float_value = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::SCAMPProto::RepeatedFloat::_InternalParse;
        object = msg->mutable_float_value();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // .SCAMPProto.RepeatedDouble double_value = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::SCAMPProto::RepeatedDouble::_InternalParse;
        object = msg->mutable_double_value();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ProfileData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SCAMPProto.ProfileData)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .SCAMPProto.RepeatedUInt uint32_value = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_uint32_value()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .SCAMPProto.RepeatedULong uint64_value = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_uint64_value()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .SCAMPProto.RepeatedFloat float_value = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_float_value()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .SCAMPProto.RepeatedDouble double_value = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_double_value()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SCAMPProto.ProfileData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SCAMPProto.ProfileData)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ProfileData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SCAMPProto.ProfileData)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .SCAMPProto.RepeatedUInt uint32_value = 1;
  if (has_uint32_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::uint32_value(this), output);
  }

  // .SCAMPProto.RepeatedULong uint64_value = 2;
  if (has_uint64_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::uint64_value(this), output);
  }

  // .SCAMPProto.RepeatedFloat float_value = 3;
  if (has_float_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::float_value(this), output);
  }

  // .SCAMPProto.RepeatedDouble double_value = 4;
  if (has_double_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, HasBitSetters::double_value(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SCAMPProto.ProfileData)
}

::google::protobuf::uint8* ProfileData::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SCAMPProto.ProfileData)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .SCAMPProto.RepeatedUInt uint32_value = 1;
  if (has_uint32_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::uint32_value(this), target);
  }

  // .SCAMPProto.RepeatedULong uint64_value = 2;
  if (has_uint64_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::uint64_value(this), target);
  }

  // .SCAMPProto.RepeatedFloat float_value = 3;
  if (has_float_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::float_value(this), target);
  }

  // .SCAMPProto.RepeatedDouble double_value = 4;
  if (has_double_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, HasBitSetters::double_value(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SCAMPProto.ProfileData)
  return target;
}

size_t ProfileData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SCAMPProto.ProfileData)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (Data_case()) {
    // .SCAMPProto.RepeatedUInt uint32_value = 1;
    case kUint32Value: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *Data_.uint32_value_);
      break;
    }
    // .SCAMPProto.RepeatedULong uint64_value = 2;
    case kUint64Value: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *Data_.uint64_value_);
      break;
    }
    // .SCAMPProto.RepeatedFloat float_value = 3;
    case kFloatValue: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *Data_.float_value_);
      break;
    }
    // .SCAMPProto.RepeatedDouble double_value = 4;
    case kDoubleValue: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *Data_.double_value_);
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ProfileData::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SCAMPProto.ProfileData)
  GOOGLE_DCHECK_NE(&from, this);
  const ProfileData* source =
      ::google::protobuf::DynamicCastToGenerated<ProfileData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SCAMPProto.ProfileData)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SCAMPProto.ProfileData)
    MergeFrom(*source);
  }
}

void ProfileData::MergeFrom(const ProfileData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SCAMPProto.ProfileData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.Data_case()) {
    case kUint32Value: {
      mutable_uint32_value()->::SCAMPProto::RepeatedUInt::MergeFrom(from.uint32_value());
      break;
    }
    case kUint64Value: {
      mutable_uint64_value()->::SCAMPProto::RepeatedULong::MergeFrom(from.uint64_value());
      break;
    }
    case kFloatValue: {
      mutable_float_value()->::SCAMPProto::RepeatedFloat::MergeFrom(from.float_value());
      break;
    }
    case kDoubleValue: {
      mutable_double_value()->::SCAMPProto::RepeatedDouble::MergeFrom(from.double_value());
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
}

void ProfileData::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SCAMPProto.ProfileData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ProfileData::CopyFrom(const ProfileData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SCAMPProto.ProfileData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProfileData::IsInitialized() const {
  return true;
}

void ProfileData::Swap(ProfileData* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ProfileData::InternalSwap(ProfileData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(Data_, other->Data_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::google::protobuf::Metadata ProfileData::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_scamp_2eproto);
  return ::file_level_metadata_scamp_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Profile::InitAsDefaultInstance() {
}
class Profile::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Profile::kDataFieldNumber;
const int Profile::kTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Profile::Profile()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SCAMPProto.Profile)
}
Profile::Profile(const Profile& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      data_(from.data_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:SCAMPProto.Profile)
}

void Profile::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Profile_scamp_2eproto.base);
  type_ = 0;
}

Profile::~Profile() {
  // @@protoc_insertion_point(destructor:SCAMPProto.Profile)
  SharedDtor();
}

void Profile::SharedDtor() {
}

void Profile::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Profile& Profile::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Profile_scamp_2eproto.base);
  return *internal_default_instance();
}


void Profile::Clear() {
// @@protoc_insertion_point(message_clear_start:SCAMPProto.Profile)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  data_.Clear();
  type_ = 0;
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Profile::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Profile*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated .SCAMPProto.ProfileData data = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::SCAMPProto::ProfileData::_InternalParse;
          object = msg->add_data();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      // .SCAMPProto.SCAMPProfileType type = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        msg->set_type(static_cast<::SCAMPProto::SCAMPProfileType>(val));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Profile::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SCAMPProto.Profile)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .SCAMPProto.ProfileData data = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_data()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .SCAMPProto.SCAMPProfileType type = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_type(static_cast< ::SCAMPProto::SCAMPProfileType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SCAMPProto.Profile)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SCAMPProto.Profile)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Profile::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SCAMPProto.Profile)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .SCAMPProto.ProfileData data = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->data_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->data(static_cast<int>(i)),
      output);
  }

  // .SCAMPProto.SCAMPProfileType type = 2;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SCAMPProto.Profile)
}

::google::protobuf::uint8* Profile::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SCAMPProto.Profile)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .SCAMPProto.ProfileData data = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->data_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->data(static_cast<int>(i)), target);
  }

  // .SCAMPProto.SCAMPProfileType type = 2;
  if (this->type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SCAMPProto.Profile)
  return target;
}

size_t Profile::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SCAMPProto.Profile)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .SCAMPProto.ProfileData data = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->data_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->data(static_cast<int>(i)));
    }
  }

  // .SCAMPProto.SCAMPProfileType type = 2;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Profile::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SCAMPProto.Profile)
  GOOGLE_DCHECK_NE(&from, this);
  const Profile* source =
      ::google::protobuf::DynamicCastToGenerated<Profile>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SCAMPProto.Profile)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SCAMPProto.Profile)
    MergeFrom(*source);
  }
}

void Profile::MergeFrom(const Profile& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SCAMPProto.Profile)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  data_.MergeFrom(from.data_);
  if (from.type() != 0) {
    set_type(from.type());
  }
}

void Profile::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SCAMPProto.Profile)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Profile::CopyFrom(const Profile& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SCAMPProto.Profile)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Profile::IsInitialized() const {
  return true;
}

void Profile::Swap(Profile* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Profile::InternalSwap(Profile* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  CastToBase(&data_)->InternalSwap(CastToBase(&other->data_));
  swap(type_, other->type_);
}

::google::protobuf::Metadata Profile::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_scamp_2eproto);
  return ::file_level_metadata_scamp_2eproto[kIndexInFileMessages];
}


// ===================================================================

void SCAMPTileInfo::InitAsDefaultInstance() {
}
class SCAMPTileInfo::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SCAMPTileInfo::SCAMPTileInfo()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SCAMPProto.SCAMPTileInfo)
}
SCAMPTileInfo::SCAMPTileInfo(const SCAMPTileInfo& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:SCAMPProto.SCAMPTileInfo)
}

void SCAMPTileInfo::SharedCtor() {
}

SCAMPTileInfo::~SCAMPTileInfo() {
  // @@protoc_insertion_point(destructor:SCAMPProto.SCAMPTileInfo)
  SharedDtor();
}

void SCAMPTileInfo::SharedDtor() {
}

void SCAMPTileInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SCAMPTileInfo& SCAMPTileInfo::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_SCAMPTileInfo_scamp_2eproto.base);
  return *internal_default_instance();
}


void SCAMPTileInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:SCAMPProto.SCAMPTileInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SCAMPTileInfo::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<SCAMPTileInfo*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      default: {
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SCAMPTileInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SCAMPProto.SCAMPTileInfo)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, _internal_metadata_.mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:SCAMPProto.SCAMPTileInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SCAMPProto.SCAMPTileInfo)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SCAMPTileInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SCAMPProto.SCAMPTileInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SCAMPProto.SCAMPTileInfo)
}

::google::protobuf::uint8* SCAMPTileInfo::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SCAMPProto.SCAMPTileInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SCAMPProto.SCAMPTileInfo)
  return target;
}

size_t SCAMPTileInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SCAMPProto.SCAMPTileInfo)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SCAMPTileInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SCAMPProto.SCAMPTileInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const SCAMPTileInfo* source =
      ::google::protobuf::DynamicCastToGenerated<SCAMPTileInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SCAMPProto.SCAMPTileInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SCAMPProto.SCAMPTileInfo)
    MergeFrom(*source);
  }
}

void SCAMPTileInfo::MergeFrom(const SCAMPTileInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SCAMPProto.SCAMPTileInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void SCAMPTileInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SCAMPProto.SCAMPTileInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SCAMPTileInfo::CopyFrom(const SCAMPTileInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SCAMPProto.SCAMPTileInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SCAMPTileInfo::IsInitialized() const {
  return true;
}

void SCAMPTileInfo::Swap(SCAMPTileInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SCAMPTileInfo::InternalSwap(SCAMPTileInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata SCAMPTileInfo::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_scamp_2eproto);
  return ::file_level_metadata_scamp_2eproto[kIndexInFileMessages];
}


// ===================================================================

void SCAMPArgs::InitAsDefaultInstance() {
  ::SCAMPProto::_SCAMPArgs_default_instance_._instance.get_mutable()->profile_a_ = const_cast< ::SCAMPProto::Profile*>(
      ::SCAMPProto::Profile::internal_default_instance());
  ::SCAMPProto::_SCAMPArgs_default_instance_._instance.get_mutable()->profile_b_ = const_cast< ::SCAMPProto::Profile*>(
      ::SCAMPProto::Profile::internal_default_instance());
}
class SCAMPArgs::HasBitSetters {
 public:
  static const ::SCAMPProto::Profile& profile_a(const SCAMPArgs* msg);
  static const ::SCAMPProto::Profile& profile_b(const SCAMPArgs* msg);
};

const ::SCAMPProto::Profile&
SCAMPArgs::HasBitSetters::profile_a(const SCAMPArgs* msg) {
  return *msg->profile_a_;
}
const ::SCAMPProto::Profile&
SCAMPArgs::HasBitSetters::profile_b(const SCAMPArgs* msg) {
  return *msg->profile_b_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SCAMPArgs::kTimeseriesAFieldNumber;
const int SCAMPArgs::kTimeseriesBFieldNumber;
const int SCAMPArgs::kProfileAFieldNumber;
const int SCAMPArgs::kProfileBFieldNumber;
const int SCAMPArgs::kHasBFieldNumber;
const int SCAMPArgs::kWindowFieldNumber;
const int SCAMPArgs::kMaxTileSizeFieldNumber;
const int SCAMPArgs::kDistributedStartRowFieldNumber;
const int SCAMPArgs::kDistributedStartColFieldNumber;
const int SCAMPArgs::kDistanceThresholdFieldNumber;
const int SCAMPArgs::kPrecisionTypeFieldNumber;
const int SCAMPArgs::kProfileTypeFieldNumber;
const int SCAMPArgs::kComputingRowsFieldNumber;
const int SCAMPArgs::kComputingColumnsFieldNumber;
const int SCAMPArgs::kKeepRowsSeparateFieldNumber;
const int SCAMPArgs::kIsAlignedFieldNumber;
const int SCAMPArgs::kTimeseriesSizeAFieldNumber;
const int SCAMPArgs::kTimeseriesSizeBFieldNumber;
const int SCAMPArgs::kJobIdFieldNumber;
const int SCAMPArgs::kTileIdFieldNumber;
const int SCAMPArgs::kDistributedTileSizeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SCAMPArgs::SCAMPArgs()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SCAMPProto.SCAMPArgs)
}
SCAMPArgs::SCAMPArgs(const SCAMPArgs& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      timeseries_a_(from.timeseries_a_),
      timeseries_b_(from.timeseries_b_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_profile_a()) {
    profile_a_ = new ::SCAMPProto::Profile(*from.profile_a_);
  } else {
    profile_a_ = nullptr;
  }
  if (from.has_profile_b()) {
    profile_b_ = new ::SCAMPProto::Profile(*from.profile_b_);
  } else {
    profile_b_ = nullptr;
  }
  ::memcpy(&window_, &from.window_,
    static_cast<size_t>(reinterpret_cast<char*>(&distributed_tile_size_) -
    reinterpret_cast<char*>(&window_)) + sizeof(distributed_tile_size_));
  // @@protoc_insertion_point(copy_constructor:SCAMPProto.SCAMPArgs)
}

void SCAMPArgs::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_SCAMPArgs_scamp_2eproto.base);
  ::memset(&profile_a_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&distributed_tile_size_) -
      reinterpret_cast<char*>(&profile_a_)) + sizeof(distributed_tile_size_));
}

SCAMPArgs::~SCAMPArgs() {
  // @@protoc_insertion_point(destructor:SCAMPProto.SCAMPArgs)
  SharedDtor();
}

void SCAMPArgs::SharedDtor() {
  if (this != internal_default_instance()) delete profile_a_;
  if (this != internal_default_instance()) delete profile_b_;
}

void SCAMPArgs::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SCAMPArgs& SCAMPArgs::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_SCAMPArgs_scamp_2eproto.base);
  return *internal_default_instance();
}


void SCAMPArgs::Clear() {
// @@protoc_insertion_point(message_clear_start:SCAMPProto.SCAMPArgs)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  timeseries_a_.Clear();
  timeseries_b_.Clear();
  if (GetArenaNoVirtual() == nullptr && profile_a_ != nullptr) {
    delete profile_a_;
  }
  profile_a_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && profile_b_ != nullptr) {
    delete profile_b_;
  }
  profile_b_ = nullptr;
  ::memset(&window_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&distributed_tile_size_) -
      reinterpret_cast<char*>(&window_)) + sizeof(distributed_tile_size_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SCAMPArgs::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<SCAMPArgs*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated double timeseries_a = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) == 10) {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::google::protobuf::internal::PackedDoubleParser;
          object = msg->mutable_timeseries_a();
          if (size > end - ptr) goto len_delim_till_end;
          auto newend = ptr + size;
          if (size) ptr = parser_till_end(ptr, newend, object, ctx);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        do {
          msg->add_timeseries_a(::google::protobuf::io::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 9 && (ptr += 1));
        break;
      }
      // repeated double timeseries_b = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) == 18) {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::google::protobuf::internal::PackedDoubleParser;
          object = msg->mutable_timeseries_b();
          if (size > end - ptr) goto len_delim_till_end;
          auto newend = ptr + size;
          if (size) ptr = parser_till_end(ptr, newend, object, ctx);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        do {
          msg->add_timeseries_b(::google::protobuf::io::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 17 && (ptr += 1));
        break;
      }
      // .SCAMPProto.Profile profile_a = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::SCAMPProto::Profile::_InternalParse;
        object = msg->mutable_profile_a();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // .SCAMPProto.Profile profile_b = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::SCAMPProto::Profile::_InternalParse;
        object = msg->mutable_profile_b();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // bool has_b = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        msg->set_has_b(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // uint64 window = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        msg->set_window(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // uint64 max_tile_size = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 56) goto handle_unusual;
        msg->set_max_tile_size(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // int64 distributed_start_row = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 64) goto handle_unusual;
        msg->set_distributed_start_row(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // int64 distributed_start_col = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 72) goto handle_unusual;
        msg->set_distributed_start_col(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // double distance_threshold = 10;
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 81) goto handle_unusual;
        msg->set_distance_threshold(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // .SCAMPProto.SCAMPPrecisionType precision_type = 11;
      case 11: {
        if (static_cast<::google::protobuf::uint8>(tag) != 88) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        msg->set_precision_type(static_cast<::SCAMPProto::SCAMPPrecisionType>(val));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // .SCAMPProto.SCAMPProfileType profile_type = 12;
      case 12: {
        if (static_cast<::google::protobuf::uint8>(tag) != 96) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        msg->set_profile_type(static_cast<::SCAMPProto::SCAMPProfileType>(val));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // bool computing_rows = 13;
      case 13: {
        if (static_cast<::google::protobuf::uint8>(tag) != 104) goto handle_unusual;
        msg->set_computing_rows(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // bool computing_columns = 14;
      case 14: {
        if (static_cast<::google::protobuf::uint8>(tag) != 112) goto handle_unusual;
        msg->set_computing_columns(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // bool keep_rows_separate = 15;
      case 15: {
        if (static_cast<::google::protobuf::uint8>(tag) != 120) goto handle_unusual;
        msg->set_keep_rows_separate(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // bool is_aligned = 16;
      case 16: {
        if (static_cast<::google::protobuf::uint8>(tag) != 128) goto handle_unusual;
        msg->set_is_aligned(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // int64 timeseries_size_a = 17;
      case 17: {
        if (static_cast<::google::protobuf::uint8>(tag) != 136) goto handle_unusual;
        msg->set_timeseries_size_a(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // int64 timeseries_size_b = 18;
      case 18: {
        if (static_cast<::google::protobuf::uint8>(tag) != 144) goto handle_unusual;
        msg->set_timeseries_size_b(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // int64 job_id = 19;
      case 19: {
        if (static_cast<::google::protobuf::uint8>(tag) != 152) goto handle_unusual;
        msg->set_job_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // int64 tile_id = 20;
      case 20: {
        if (static_cast<::google::protobuf::uint8>(tag) != 160) goto handle_unusual;
        msg->set_tile_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // int64 distributed_tile_size = 21;
      case 21: {
        if (static_cast<::google::protobuf::uint8>(tag) != 168) goto handle_unusual;
        msg->set_distributed_tile_size(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SCAMPArgs::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SCAMPProto.SCAMPArgs)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated double timeseries_a = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_timeseries_a())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 10u, input, this->mutable_timeseries_a())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated double timeseries_b = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_timeseries_b())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 18u, input, this->mutable_timeseries_b())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .SCAMPProto.Profile profile_a = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_profile_a()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .SCAMPProto.Profile profile_b = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_profile_b()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_b = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_b_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint64 window = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &window_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint64 max_tile_size = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &max_tile_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int64 distributed_start_row = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (64 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &distributed_start_row_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int64 distributed_start_col = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (72 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &distributed_start_col_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double distance_threshold = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (81 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &distance_threshold_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .SCAMPProto.SCAMPPrecisionType precision_type = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (88 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_precision_type(static_cast< ::SCAMPProto::SCAMPPrecisionType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .SCAMPProto.SCAMPProfileType profile_type = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (96 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_profile_type(static_cast< ::SCAMPProto::SCAMPProfileType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool computing_rows = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (104 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &computing_rows_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool computing_columns = 14;
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (112 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &computing_columns_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool keep_rows_separate = 15;
      case 15: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (120 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &keep_rows_separate_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool is_aligned = 16;
      case 16: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (128 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_aligned_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int64 timeseries_size_a = 17;
      case 17: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (136 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &timeseries_size_a_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int64 timeseries_size_b = 18;
      case 18: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (144 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &timeseries_size_b_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int64 job_id = 19;
      case 19: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (152 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &job_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int64 tile_id = 20;
      case 20: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (160 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &tile_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int64 distributed_tile_size = 21;
      case 21: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (168 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &distributed_tile_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SCAMPProto.SCAMPArgs)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SCAMPProto.SCAMPArgs)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SCAMPArgs::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SCAMPProto.SCAMPArgs)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double timeseries_a = 1;
  if (this->timeseries_a_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_timeseries_a_cached_byte_size_.load(
        std::memory_order_relaxed));
    ::google::protobuf::internal::WireFormatLite::WriteDoubleArray(
      this->timeseries_a().data(), this->timeseries_a_size(), output);
  }

  // repeated double timeseries_b = 2;
  if (this->timeseries_b_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(2, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_timeseries_b_cached_byte_size_.load(
        std::memory_order_relaxed));
    ::google::protobuf::internal::WireFormatLite::WriteDoubleArray(
      this->timeseries_b().data(), this->timeseries_b_size(), output);
  }

  // .SCAMPProto.Profile profile_a = 3;
  if (this->has_profile_a()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::profile_a(this), output);
  }

  // .SCAMPProto.Profile profile_b = 4;
  if (this->has_profile_b()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, HasBitSetters::profile_b(this), output);
  }

  // bool has_b = 5;
  if (this->has_b() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->has_b(), output);
  }

  // uint64 window = 6;
  if (this->window() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->window(), output);
  }

  // uint64 max_tile_size = 7;
  if (this->max_tile_size() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(7, this->max_tile_size(), output);
  }

  // int64 distributed_start_row = 8;
  if (this->distributed_start_row() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(8, this->distributed_start_row(), output);
  }

  // int64 distributed_start_col = 9;
  if (this->distributed_start_col() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(9, this->distributed_start_col(), output);
  }

  // double distance_threshold = 10;
  if (this->distance_threshold() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(10, this->distance_threshold(), output);
  }

  // .SCAMPProto.SCAMPPrecisionType precision_type = 11;
  if (this->precision_type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      11, this->precision_type(), output);
  }

  // .SCAMPProto.SCAMPProfileType profile_type = 12;
  if (this->profile_type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      12, this->profile_type(), output);
  }

  // bool computing_rows = 13;
  if (this->computing_rows() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(13, this->computing_rows(), output);
  }

  // bool computing_columns = 14;
  if (this->computing_columns() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(14, this->computing_columns(), output);
  }

  // bool keep_rows_separate = 15;
  if (this->keep_rows_separate() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(15, this->keep_rows_separate(), output);
  }

  // bool is_aligned = 16;
  if (this->is_aligned() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(16, this->is_aligned(), output);
  }

  // int64 timeseries_size_a = 17;
  if (this->timeseries_size_a() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(17, this->timeseries_size_a(), output);
  }

  // int64 timeseries_size_b = 18;
  if (this->timeseries_size_b() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(18, this->timeseries_size_b(), output);
  }

  // int64 job_id = 19;
  if (this->job_id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(19, this->job_id(), output);
  }

  // int64 tile_id = 20;
  if (this->tile_id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(20, this->tile_id(), output);
  }

  // int64 distributed_tile_size = 21;
  if (this->distributed_tile_size() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(21, this->distributed_tile_size(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SCAMPProto.SCAMPArgs)
}

::google::protobuf::uint8* SCAMPArgs::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SCAMPProto.SCAMPArgs)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double timeseries_a = 1;
  if (this->timeseries_a_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      1,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
        _timeseries_a_cached_byte_size_.load(std::memory_order_relaxed),
         target);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteDoubleNoTagToArray(this->timeseries_a_, target);
  }

  // repeated double timeseries_b = 2;
  if (this->timeseries_b_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      2,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
        _timeseries_b_cached_byte_size_.load(std::memory_order_relaxed),
         target);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteDoubleNoTagToArray(this->timeseries_b_, target);
  }

  // .SCAMPProto.Profile profile_a = 3;
  if (this->has_profile_a()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::profile_a(this), target);
  }

  // .SCAMPProto.Profile profile_b = 4;
  if (this->has_profile_b()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, HasBitSetters::profile_b(this), target);
  }

  // bool has_b = 5;
  if (this->has_b() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->has_b(), target);
  }

  // uint64 window = 6;
  if (this->window() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->window(), target);
  }

  // uint64 max_tile_size = 7;
  if (this->max_tile_size() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(7, this->max_tile_size(), target);
  }

  // int64 distributed_start_row = 8;
  if (this->distributed_start_row() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(8, this->distributed_start_row(), target);
  }

  // int64 distributed_start_col = 9;
  if (this->distributed_start_col() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(9, this->distributed_start_col(), target);
  }

  // double distance_threshold = 10;
  if (this->distance_threshold() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(10, this->distance_threshold(), target);
  }

  // .SCAMPProto.SCAMPPrecisionType precision_type = 11;
  if (this->precision_type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      11, this->precision_type(), target);
  }

  // .SCAMPProto.SCAMPProfileType profile_type = 12;
  if (this->profile_type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      12, this->profile_type(), target);
  }

  // bool computing_rows = 13;
  if (this->computing_rows() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(13, this->computing_rows(), target);
  }

  // bool computing_columns = 14;
  if (this->computing_columns() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(14, this->computing_columns(), target);
  }

  // bool keep_rows_separate = 15;
  if (this->keep_rows_separate() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(15, this->keep_rows_separate(), target);
  }

  // bool is_aligned = 16;
  if (this->is_aligned() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(16, this->is_aligned(), target);
  }

  // int64 timeseries_size_a = 17;
  if (this->timeseries_size_a() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(17, this->timeseries_size_a(), target);
  }

  // int64 timeseries_size_b = 18;
  if (this->timeseries_size_b() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(18, this->timeseries_size_b(), target);
  }

  // int64 job_id = 19;
  if (this->job_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(19, this->job_id(), target);
  }

  // int64 tile_id = 20;
  if (this->tile_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(20, this->tile_id(), target);
  }

  // int64 distributed_tile_size = 21;
  if (this->distributed_tile_size() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(21, this->distributed_tile_size(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SCAMPProto.SCAMPArgs)
  return target;
}

size_t SCAMPArgs::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SCAMPProto.SCAMPArgs)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double timeseries_a = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->timeseries_a_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
            static_cast<::google::protobuf::int32>(data_size));
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    _timeseries_a_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated double timeseries_b = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->timeseries_b_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
            static_cast<::google::protobuf::int32>(data_size));
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    _timeseries_b_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // .SCAMPProto.Profile profile_a = 3;
  if (this->has_profile_a()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *profile_a_);
  }

  // .SCAMPProto.Profile profile_b = 4;
  if (this->has_profile_b()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *profile_b_);
  }

  // uint64 window = 6;
  if (this->window() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->window());
  }

  // uint64 max_tile_size = 7;
  if (this->max_tile_size() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->max_tile_size());
  }

  // int64 distributed_start_row = 8;
  if (this->distributed_start_row() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->distributed_start_row());
  }

  // int64 distributed_start_col = 9;
  if (this->distributed_start_col() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->distributed_start_col());
  }

  // double distance_threshold = 10;
  if (this->distance_threshold() != 0) {
    total_size += 1 + 8;
  }

  // .SCAMPProto.SCAMPPrecisionType precision_type = 11;
  if (this->precision_type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->precision_type());
  }

  // bool has_b = 5;
  if (this->has_b() != 0) {
    total_size += 1 + 1;
  }

  // bool computing_rows = 13;
  if (this->computing_rows() != 0) {
    total_size += 1 + 1;
  }

  // bool computing_columns = 14;
  if (this->computing_columns() != 0) {
    total_size += 1 + 1;
  }

  // bool keep_rows_separate = 15;
  if (this->keep_rows_separate() != 0) {
    total_size += 1 + 1;
  }

  // .SCAMPProto.SCAMPProfileType profile_type = 12;
  if (this->profile_type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->profile_type());
  }

  // bool is_aligned = 16;
  if (this->is_aligned() != 0) {
    total_size += 2 + 1;
  }

  // int64 timeseries_size_a = 17;
  if (this->timeseries_size_a() != 0) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->timeseries_size_a());
  }

  // int64 timeseries_size_b = 18;
  if (this->timeseries_size_b() != 0) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->timeseries_size_b());
  }

  // int64 job_id = 19;
  if (this->job_id() != 0) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->job_id());
  }

  // int64 tile_id = 20;
  if (this->tile_id() != 0) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->tile_id());
  }

  // int64 distributed_tile_size = 21;
  if (this->distributed_tile_size() != 0) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->distributed_tile_size());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SCAMPArgs::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SCAMPProto.SCAMPArgs)
  GOOGLE_DCHECK_NE(&from, this);
  const SCAMPArgs* source =
      ::google::protobuf::DynamicCastToGenerated<SCAMPArgs>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SCAMPProto.SCAMPArgs)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SCAMPProto.SCAMPArgs)
    MergeFrom(*source);
  }
}

void SCAMPArgs::MergeFrom(const SCAMPArgs& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SCAMPProto.SCAMPArgs)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  timeseries_a_.MergeFrom(from.timeseries_a_);
  timeseries_b_.MergeFrom(from.timeseries_b_);
  if (from.has_profile_a()) {
    mutable_profile_a()->::SCAMPProto::Profile::MergeFrom(from.profile_a());
  }
  if (from.has_profile_b()) {
    mutable_profile_b()->::SCAMPProto::Profile::MergeFrom(from.profile_b());
  }
  if (from.window() != 0) {
    set_window(from.window());
  }
  if (from.max_tile_size() != 0) {
    set_max_tile_size(from.max_tile_size());
  }
  if (from.distributed_start_row() != 0) {
    set_distributed_start_row(from.distributed_start_row());
  }
  if (from.distributed_start_col() != 0) {
    set_distributed_start_col(from.distributed_start_col());
  }
  if (from.distance_threshold() != 0) {
    set_distance_threshold(from.distance_threshold());
  }
  if (from.precision_type() != 0) {
    set_precision_type(from.precision_type());
  }
  if (from.has_b() != 0) {
    set_has_b(from.has_b());
  }
  if (from.computing_rows() != 0) {
    set_computing_rows(from.computing_rows());
  }
  if (from.computing_columns() != 0) {
    set_computing_columns(from.computing_columns());
  }
  if (from.keep_rows_separate() != 0) {
    set_keep_rows_separate(from.keep_rows_separate());
  }
  if (from.profile_type() != 0) {
    set_profile_type(from.profile_type());
  }
  if (from.is_aligned() != 0) {
    set_is_aligned(from.is_aligned());
  }
  if (from.timeseries_size_a() != 0) {
    set_timeseries_size_a(from.timeseries_size_a());
  }
  if (from.timeseries_size_b() != 0) {
    set_timeseries_size_b(from.timeseries_size_b());
  }
  if (from.job_id() != 0) {
    set_job_id(from.job_id());
  }
  if (from.tile_id() != 0) {
    set_tile_id(from.tile_id());
  }
  if (from.distributed_tile_size() != 0) {
    set_distributed_tile_size(from.distributed_tile_size());
  }
}

void SCAMPArgs::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SCAMPProto.SCAMPArgs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SCAMPArgs::CopyFrom(const SCAMPArgs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SCAMPProto.SCAMPArgs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SCAMPArgs::IsInitialized() const {
  return true;
}

void SCAMPArgs::Swap(SCAMPArgs* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SCAMPArgs::InternalSwap(SCAMPArgs* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  timeseries_a_.InternalSwap(&other->timeseries_a_);
  timeseries_b_.InternalSwap(&other->timeseries_b_);
  swap(profile_a_, other->profile_a_);
  swap(profile_b_, other->profile_b_);
  swap(window_, other->window_);
  swap(max_tile_size_, other->max_tile_size_);
  swap(distributed_start_row_, other->distributed_start_row_);
  swap(distributed_start_col_, other->distributed_start_col_);
  swap(distance_threshold_, other->distance_threshold_);
  swap(precision_type_, other->precision_type_);
  swap(has_b_, other->has_b_);
  swap(computing_rows_, other->computing_rows_);
  swap(computing_columns_, other->computing_columns_);
  swap(keep_rows_separate_, other->keep_rows_separate_);
  swap(profile_type_, other->profile_type_);
  swap(is_aligned_, other->is_aligned_);
  swap(timeseries_size_a_, other->timeseries_size_a_);
  swap(timeseries_size_b_, other->timeseries_size_b_);
  swap(job_id_, other->job_id_);
  swap(tile_id_, other->tile_id_);
  swap(distributed_tile_size_, other->distributed_tile_size_);
}

::google::protobuf::Metadata SCAMPArgs::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_scamp_2eproto);
  return ::file_level_metadata_scamp_2eproto[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace SCAMPProto
namespace google {
namespace protobuf {
template<> PROTOBUF_NOINLINE ::SCAMPProto::SCAMPWork* Arena::CreateMaybeMessage< ::SCAMPProto::SCAMPWork >(Arena* arena) {
  return Arena::CreateInternal< ::SCAMPProto::SCAMPWork >(arena);
}
template<> PROTOBUF_NOINLINE ::SCAMPProto::SCAMPStatus* Arena::CreateMaybeMessage< ::SCAMPProto::SCAMPStatus >(Arena* arena) {
  return Arena::CreateInternal< ::SCAMPProto::SCAMPStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::SCAMPProto::SCAMPJobID* Arena::CreateMaybeMessage< ::SCAMPProto::SCAMPJobID >(Arena* arena) {
  return Arena::CreateInternal< ::SCAMPProto::SCAMPJobID >(arena);
}
template<> PROTOBUF_NOINLINE ::SCAMPProto::SCAMPRequest* Arena::CreateMaybeMessage< ::SCAMPProto::SCAMPRequest >(Arena* arena) {
  return Arena::CreateInternal< ::SCAMPProto::SCAMPRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::SCAMPProto::SCAMPResult* Arena::CreateMaybeMessage< ::SCAMPProto::SCAMPResult >(Arena* arena) {
  return Arena::CreateInternal< ::SCAMPProto::SCAMPResult >(arena);
}
template<> PROTOBUF_NOINLINE ::SCAMPProto::RepeatedUInt* Arena::CreateMaybeMessage< ::SCAMPProto::RepeatedUInt >(Arena* arena) {
  return Arena::CreateInternal< ::SCAMPProto::RepeatedUInt >(arena);
}
template<> PROTOBUF_NOINLINE ::SCAMPProto::RepeatedULong* Arena::CreateMaybeMessage< ::SCAMPProto::RepeatedULong >(Arena* arena) {
  return Arena::CreateInternal< ::SCAMPProto::RepeatedULong >(arena);
}
template<> PROTOBUF_NOINLINE ::SCAMPProto::RepeatedFloat* Arena::CreateMaybeMessage< ::SCAMPProto::RepeatedFloat >(Arena* arena) {
  return Arena::CreateInternal< ::SCAMPProto::RepeatedFloat >(arena);
}
template<> PROTOBUF_NOINLINE ::SCAMPProto::RepeatedDouble* Arena::CreateMaybeMessage< ::SCAMPProto::RepeatedDouble >(Arena* arena) {
  return Arena::CreateInternal< ::SCAMPProto::RepeatedDouble >(arena);
}
template<> PROTOBUF_NOINLINE ::SCAMPProto::ProfileData* Arena::CreateMaybeMessage< ::SCAMPProto::ProfileData >(Arena* arena) {
  return Arena::CreateInternal< ::SCAMPProto::ProfileData >(arena);
}
template<> PROTOBUF_NOINLINE ::SCAMPProto::Profile* Arena::CreateMaybeMessage< ::SCAMPProto::Profile >(Arena* arena) {
  return Arena::CreateInternal< ::SCAMPProto::Profile >(arena);
}
template<> PROTOBUF_NOINLINE ::SCAMPProto::SCAMPTileInfo* Arena::CreateMaybeMessage< ::SCAMPProto::SCAMPTileInfo >(Arena* arena) {
  return Arena::CreateInternal< ::SCAMPProto::SCAMPTileInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::SCAMPProto::SCAMPArgs* Arena::CreateMaybeMessage< ::SCAMPProto::SCAMPArgs >(Arena* arena) {
  return Arena::CreateInternal< ::SCAMPProto::SCAMPArgs >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
