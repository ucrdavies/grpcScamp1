// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scamp.proto

#ifndef PROTOBUF_INCLUDED_scamp_2eproto
#define PROTOBUF_INCLUDED_scamp_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_scamp_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_scamp_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_scamp_2eproto();
namespace SCAMPProto {
class Profile;
class ProfileDefaultTypeInternal;
extern ProfileDefaultTypeInternal _Profile_default_instance_;
class ProfileData;
class ProfileDataDefaultTypeInternal;
extern ProfileDataDefaultTypeInternal _ProfileData_default_instance_;
class RepeatedDouble;
class RepeatedDoubleDefaultTypeInternal;
extern RepeatedDoubleDefaultTypeInternal _RepeatedDouble_default_instance_;
class RepeatedFloat;
class RepeatedFloatDefaultTypeInternal;
extern RepeatedFloatDefaultTypeInternal _RepeatedFloat_default_instance_;
class RepeatedUInt;
class RepeatedUIntDefaultTypeInternal;
extern RepeatedUIntDefaultTypeInternal _RepeatedUInt_default_instance_;
class RepeatedULong;
class RepeatedULongDefaultTypeInternal;
extern RepeatedULongDefaultTypeInternal _RepeatedULong_default_instance_;
class SCAMPArgs;
class SCAMPArgsDefaultTypeInternal;
extern SCAMPArgsDefaultTypeInternal _SCAMPArgs_default_instance_;
class SCAMPJobID;
class SCAMPJobIDDefaultTypeInternal;
extern SCAMPJobIDDefaultTypeInternal _SCAMPJobID_default_instance_;
class SCAMPRequest;
class SCAMPRequestDefaultTypeInternal;
extern SCAMPRequestDefaultTypeInternal _SCAMPRequest_default_instance_;
class SCAMPResult;
class SCAMPResultDefaultTypeInternal;
extern SCAMPResultDefaultTypeInternal _SCAMPResult_default_instance_;
class SCAMPStatus;
class SCAMPStatusDefaultTypeInternal;
extern SCAMPStatusDefaultTypeInternal _SCAMPStatus_default_instance_;
class SCAMPTileInfo;
class SCAMPTileInfoDefaultTypeInternal;
extern SCAMPTileInfoDefaultTypeInternal _SCAMPTileInfo_default_instance_;
class SCAMPWork;
class SCAMPWorkDefaultTypeInternal;
extern SCAMPWorkDefaultTypeInternal _SCAMPWork_default_instance_;
}  // namespace SCAMPProto
namespace google {
namespace protobuf {
template<> ::SCAMPProto::Profile* Arena::CreateMaybeMessage<::SCAMPProto::Profile>(Arena*);
template<> ::SCAMPProto::ProfileData* Arena::CreateMaybeMessage<::SCAMPProto::ProfileData>(Arena*);
template<> ::SCAMPProto::RepeatedDouble* Arena::CreateMaybeMessage<::SCAMPProto::RepeatedDouble>(Arena*);
template<> ::SCAMPProto::RepeatedFloat* Arena::CreateMaybeMessage<::SCAMPProto::RepeatedFloat>(Arena*);
template<> ::SCAMPProto::RepeatedUInt* Arena::CreateMaybeMessage<::SCAMPProto::RepeatedUInt>(Arena*);
template<> ::SCAMPProto::RepeatedULong* Arena::CreateMaybeMessage<::SCAMPProto::RepeatedULong>(Arena*);
template<> ::SCAMPProto::SCAMPArgs* Arena::CreateMaybeMessage<::SCAMPProto::SCAMPArgs>(Arena*);
template<> ::SCAMPProto::SCAMPJobID* Arena::CreateMaybeMessage<::SCAMPProto::SCAMPJobID>(Arena*);
template<> ::SCAMPProto::SCAMPRequest* Arena::CreateMaybeMessage<::SCAMPProto::SCAMPRequest>(Arena*);
template<> ::SCAMPProto::SCAMPResult* Arena::CreateMaybeMessage<::SCAMPProto::SCAMPResult>(Arena*);
template<> ::SCAMPProto::SCAMPStatus* Arena::CreateMaybeMessage<::SCAMPProto::SCAMPStatus>(Arena*);
template<> ::SCAMPProto::SCAMPTileInfo* Arena::CreateMaybeMessage<::SCAMPProto::SCAMPTileInfo>(Arena*);
template<> ::SCAMPProto::SCAMPWork* Arena::CreateMaybeMessage<::SCAMPProto::SCAMPWork>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace SCAMPProto {

enum JobStatus {
  JOB_STATUS_INVALID = 0,
  JOB_STATUS_READY = 1,
  JOB_STATUS_RUNNING = 2,
  JOB_STATUS_FINISHED = 3,
  JOB_STATUS_FAILED = 4,
  JobStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  JobStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool JobStatus_IsValid(int value);
const JobStatus JobStatus_MIN = JOB_STATUS_INVALID;
const JobStatus JobStatus_MAX = JOB_STATUS_FAILED;
const int JobStatus_ARRAYSIZE = JobStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* JobStatus_descriptor();
inline const ::std::string& JobStatus_Name(JobStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    JobStatus_descriptor(), value);
}
inline bool JobStatus_Parse(
    const ::std::string& name, JobStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<JobStatus>(
    JobStatus_descriptor(), name, value);
}
enum SCAMPProfileType {
  PROFILE_TYPE_INVALID = 0,
  PROFILE_TYPE_1NN_INDEX = 1,
  PROFILE_TYPE_SUM_THRESH = 2,
  PROFILE_TYPE_FREQUENCY_THRESH = 3,
  PROFILE_TYPE_KNN = 4,
  PROFILE_TYPE_1NN_MULTIDIM = 5,
  PROFILE_TYPE_1NN = 6,
  SCAMPProfileType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  SCAMPProfileType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool SCAMPProfileType_IsValid(int value);
const SCAMPProfileType SCAMPProfileType_MIN = PROFILE_TYPE_INVALID;
const SCAMPProfileType SCAMPProfileType_MAX = PROFILE_TYPE_1NN;
const int SCAMPProfileType_ARRAYSIZE = SCAMPProfileType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SCAMPProfileType_descriptor();
inline const ::std::string& SCAMPProfileType_Name(SCAMPProfileType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SCAMPProfileType_descriptor(), value);
}
inline bool SCAMPProfileType_Parse(
    const ::std::string& name, SCAMPProfileType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SCAMPProfileType>(
    SCAMPProfileType_descriptor(), name, value);
}
enum SCAMPPrecisionType {
  PRECISION_INVALID = 0,
  PRECISION_SINGLE = 1,
  PRECISION_MIXED = 2,
  PRECISION_DOUBLE = 3,
  SCAMPPrecisionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  SCAMPPrecisionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool SCAMPPrecisionType_IsValid(int value);
const SCAMPPrecisionType SCAMPPrecisionType_MIN = PRECISION_INVALID;
const SCAMPPrecisionType SCAMPPrecisionType_MAX = PRECISION_DOUBLE;
const int SCAMPPrecisionType_ARRAYSIZE = SCAMPPrecisionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SCAMPPrecisionType_descriptor();
inline const ::std::string& SCAMPPrecisionType_Name(SCAMPPrecisionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SCAMPPrecisionType_descriptor(), value);
}
inline bool SCAMPPrecisionType_Parse(
    const ::std::string& name, SCAMPPrecisionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SCAMPPrecisionType>(
    SCAMPPrecisionType_descriptor(), name, value);
}
// ===================================================================

class SCAMPWork final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCAMPProto.SCAMPWork) */ {
 public:
  SCAMPWork();
  virtual ~SCAMPWork();

  SCAMPWork(const SCAMPWork& from);

  inline SCAMPWork& operator=(const SCAMPWork& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SCAMPWork(SCAMPWork&& from) noexcept
    : SCAMPWork() {
    *this = ::std::move(from);
  }

  inline SCAMPWork& operator=(SCAMPWork&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SCAMPWork& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SCAMPWork* internal_default_instance() {
    return reinterpret_cast<const SCAMPWork*>(
               &_SCAMPWork_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(SCAMPWork* other);
  friend void swap(SCAMPWork& a, SCAMPWork& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SCAMPWork* New() const final {
    return CreateMaybeMessage<SCAMPWork>(nullptr);
  }

  SCAMPWork* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SCAMPWork>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SCAMPWork& from);
  void MergeFrom(const SCAMPWork& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCAMPWork* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .SCAMPProto.SCAMPArgs args = 1;
  bool has_args() const;
  void clear_args();
  static const int kArgsFieldNumber = 1;
  const ::SCAMPProto::SCAMPArgs& args() const;
  ::SCAMPProto::SCAMPArgs* release_args();
  ::SCAMPProto::SCAMPArgs* mutable_args();
  void set_allocated_args(::SCAMPProto::SCAMPArgs* args);

  // bool valid = 2;
  void clear_valid();
  static const int kValidFieldNumber = 2;
  bool valid() const;
  void set_valid(bool value);

  // @@protoc_insertion_point(class_scope:SCAMPProto.SCAMPWork)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::SCAMPProto::SCAMPArgs* args_;
  bool valid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scamp_2eproto;
};
// -------------------------------------------------------------------

class SCAMPStatus final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCAMPProto.SCAMPStatus) */ {
 public:
  SCAMPStatus();
  virtual ~SCAMPStatus();

  SCAMPStatus(const SCAMPStatus& from);

  inline SCAMPStatus& operator=(const SCAMPStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SCAMPStatus(SCAMPStatus&& from) noexcept
    : SCAMPStatus() {
    *this = ::std::move(from);
  }

  inline SCAMPStatus& operator=(SCAMPStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SCAMPStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SCAMPStatus* internal_default_instance() {
    return reinterpret_cast<const SCAMPStatus*>(
               &_SCAMPStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(SCAMPStatus* other);
  friend void swap(SCAMPStatus& a, SCAMPStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SCAMPStatus* New() const final {
    return CreateMaybeMessage<SCAMPStatus>(nullptr);
  }

  SCAMPStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SCAMPStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SCAMPStatus& from);
  void MergeFrom(const SCAMPStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCAMPStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 job_id = 1;
  void clear_job_id();
  static const int kJobIdFieldNumber = 1;
  ::google::protobuf::int64 job_id() const;
  void set_job_id(::google::protobuf::int64 value);

  // .SCAMPProto.JobStatus status = 2;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::SCAMPProto::JobStatus status() const;
  void set_status(::SCAMPProto::JobStatus value);

  // float progress = 3;
  void clear_progress();
  static const int kProgressFieldNumber = 3;
  float progress() const;
  void set_progress(float value);

  // int64 time_elapsed = 4;
  void clear_time_elapsed();
  static const int kTimeElapsedFieldNumber = 4;
  ::google::protobuf::int64 time_elapsed() const;
  void set_time_elapsed(::google::protobuf::int64 value);

  // int64 eta = 5;
  void clear_eta();
  static const int kEtaFieldNumber = 5;
  ::google::protobuf::int64 eta() const;
  void set_eta(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:SCAMPProto.SCAMPStatus)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 job_id_;
  int status_;
  float progress_;
  ::google::protobuf::int64 time_elapsed_;
  ::google::protobuf::int64 eta_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scamp_2eproto;
};
// -------------------------------------------------------------------

class SCAMPJobID final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCAMPProto.SCAMPJobID) */ {
 public:
  SCAMPJobID();
  virtual ~SCAMPJobID();

  SCAMPJobID(const SCAMPJobID& from);

  inline SCAMPJobID& operator=(const SCAMPJobID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SCAMPJobID(SCAMPJobID&& from) noexcept
    : SCAMPJobID() {
    *this = ::std::move(from);
  }

  inline SCAMPJobID& operator=(SCAMPJobID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SCAMPJobID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SCAMPJobID* internal_default_instance() {
    return reinterpret_cast<const SCAMPJobID*>(
               &_SCAMPJobID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(SCAMPJobID* other);
  friend void swap(SCAMPJobID& a, SCAMPJobID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SCAMPJobID* New() const final {
    return CreateMaybeMessage<SCAMPJobID>(nullptr);
  }

  SCAMPJobID* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SCAMPJobID>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SCAMPJobID& from);
  void MergeFrom(const SCAMPJobID& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCAMPJobID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 job_id = 1;
  void clear_job_id();
  static const int kJobIdFieldNumber = 1;
  ::google::protobuf::uint64 job_id() const;
  void set_job_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:SCAMPProto.SCAMPJobID)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 job_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scamp_2eproto;
};
// -------------------------------------------------------------------

class SCAMPRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCAMPProto.SCAMPRequest) */ {
 public:
  SCAMPRequest();
  virtual ~SCAMPRequest();

  SCAMPRequest(const SCAMPRequest& from);

  inline SCAMPRequest& operator=(const SCAMPRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SCAMPRequest(SCAMPRequest&& from) noexcept
    : SCAMPRequest() {
    *this = ::std::move(from);
  }

  inline SCAMPRequest& operator=(SCAMPRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SCAMPRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SCAMPRequest* internal_default_instance() {
    return reinterpret_cast<const SCAMPRequest*>(
               &_SCAMPRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(SCAMPRequest* other);
  friend void swap(SCAMPRequest& a, SCAMPRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SCAMPRequest* New() const final {
    return CreateMaybeMessage<SCAMPRequest>(nullptr);
  }

  SCAMPRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SCAMPRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SCAMPRequest& from);
  void MergeFrom(const SCAMPRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCAMPRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 expected_throughput = 1;
  void clear_expected_throughput();
  static const int kExpectedThroughputFieldNumber = 1;
  ::google::protobuf::int64 expected_throughput() const;
  void set_expected_throughput(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:SCAMPProto.SCAMPRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 expected_throughput_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scamp_2eproto;
};
// -------------------------------------------------------------------

class SCAMPResult final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCAMPProto.SCAMPResult) */ {
 public:
  SCAMPResult();
  virtual ~SCAMPResult();

  SCAMPResult(const SCAMPResult& from);

  inline SCAMPResult& operator=(const SCAMPResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SCAMPResult(SCAMPResult&& from) noexcept
    : SCAMPResult() {
    *this = ::std::move(from);
  }

  inline SCAMPResult& operator=(SCAMPResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SCAMPResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SCAMPResult* internal_default_instance() {
    return reinterpret_cast<const SCAMPResult*>(
               &_SCAMPResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(SCAMPResult* other);
  friend void swap(SCAMPResult& a, SCAMPResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SCAMPResult* New() const final {
    return CreateMaybeMessage<SCAMPResult>(nullptr);
  }

  SCAMPResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SCAMPResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SCAMPResult& from);
  void MergeFrom(const SCAMPResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCAMPResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SCAMPProto.SCAMPResult)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scamp_2eproto;
};
// -------------------------------------------------------------------

class RepeatedUInt final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCAMPProto.RepeatedUInt) */ {
 public:
  RepeatedUInt();
  virtual ~RepeatedUInt();

  RepeatedUInt(const RepeatedUInt& from);

  inline RepeatedUInt& operator=(const RepeatedUInt& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RepeatedUInt(RepeatedUInt&& from) noexcept
    : RepeatedUInt() {
    *this = ::std::move(from);
  }

  inline RepeatedUInt& operator=(RepeatedUInt&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RepeatedUInt& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RepeatedUInt* internal_default_instance() {
    return reinterpret_cast<const RepeatedUInt*>(
               &_RepeatedUInt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(RepeatedUInt* other);
  friend void swap(RepeatedUInt& a, RepeatedUInt& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RepeatedUInt* New() const final {
    return CreateMaybeMessage<RepeatedUInt>(nullptr);
  }

  RepeatedUInt* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RepeatedUInt>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RepeatedUInt& from);
  void MergeFrom(const RepeatedUInt& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RepeatedUInt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::uint32 value(int index) const;
  void set_value(int index, ::google::protobuf::uint32 value);
  void add_value(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      value() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:SCAMPProto.RepeatedUInt)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > value_;
  mutable std::atomic<int> _value_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scamp_2eproto;
};
// -------------------------------------------------------------------

class RepeatedULong final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCAMPProto.RepeatedULong) */ {
 public:
  RepeatedULong();
  virtual ~RepeatedULong();

  RepeatedULong(const RepeatedULong& from);

  inline RepeatedULong& operator=(const RepeatedULong& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RepeatedULong(RepeatedULong&& from) noexcept
    : RepeatedULong() {
    *this = ::std::move(from);
  }

  inline RepeatedULong& operator=(RepeatedULong&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RepeatedULong& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RepeatedULong* internal_default_instance() {
    return reinterpret_cast<const RepeatedULong*>(
               &_RepeatedULong_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(RepeatedULong* other);
  friend void swap(RepeatedULong& a, RepeatedULong& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RepeatedULong* New() const final {
    return CreateMaybeMessage<RepeatedULong>(nullptr);
  }

  RepeatedULong* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RepeatedULong>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RepeatedULong& from);
  void MergeFrom(const RepeatedULong& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RepeatedULong* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::uint64 value(int index) const;
  void set_value(int index, ::google::protobuf::uint64 value);
  void add_value(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      value() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:SCAMPProto.RepeatedULong)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > value_;
  mutable std::atomic<int> _value_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scamp_2eproto;
};
// -------------------------------------------------------------------

class RepeatedFloat final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCAMPProto.RepeatedFloat) */ {
 public:
  RepeatedFloat();
  virtual ~RepeatedFloat();

  RepeatedFloat(const RepeatedFloat& from);

  inline RepeatedFloat& operator=(const RepeatedFloat& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RepeatedFloat(RepeatedFloat&& from) noexcept
    : RepeatedFloat() {
    *this = ::std::move(from);
  }

  inline RepeatedFloat& operator=(RepeatedFloat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RepeatedFloat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RepeatedFloat* internal_default_instance() {
    return reinterpret_cast<const RepeatedFloat*>(
               &_RepeatedFloat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(RepeatedFloat* other);
  friend void swap(RepeatedFloat& a, RepeatedFloat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RepeatedFloat* New() const final {
    return CreateMaybeMessage<RepeatedFloat>(nullptr);
  }

  RepeatedFloat* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RepeatedFloat>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RepeatedFloat& from);
  void MergeFrom(const RepeatedFloat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RepeatedFloat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  float value(int index) const;
  void set_value(int index, float value);
  void add_value(float value);
  const ::google::protobuf::RepeatedField< float >&
      value() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:SCAMPProto.RepeatedFloat)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > value_;
  mutable std::atomic<int> _value_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scamp_2eproto;
};
// -------------------------------------------------------------------

class RepeatedDouble final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCAMPProto.RepeatedDouble) */ {
 public:
  RepeatedDouble();
  virtual ~RepeatedDouble();

  RepeatedDouble(const RepeatedDouble& from);

  inline RepeatedDouble& operator=(const RepeatedDouble& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RepeatedDouble(RepeatedDouble&& from) noexcept
    : RepeatedDouble() {
    *this = ::std::move(from);
  }

  inline RepeatedDouble& operator=(RepeatedDouble&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RepeatedDouble& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RepeatedDouble* internal_default_instance() {
    return reinterpret_cast<const RepeatedDouble*>(
               &_RepeatedDouble_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(RepeatedDouble* other);
  friend void swap(RepeatedDouble& a, RepeatedDouble& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RepeatedDouble* New() const final {
    return CreateMaybeMessage<RepeatedDouble>(nullptr);
  }

  RepeatedDouble* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RepeatedDouble>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RepeatedDouble& from);
  void MergeFrom(const RepeatedDouble& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RepeatedDouble* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  double value(int index) const;
  void set_value(int index, double value);
  void add_value(double value);
  const ::google::protobuf::RepeatedField< double >&
      value() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:SCAMPProto.RepeatedDouble)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > value_;
  mutable std::atomic<int> _value_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scamp_2eproto;
};
// -------------------------------------------------------------------

class ProfileData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCAMPProto.ProfileData) */ {
 public:
  ProfileData();
  virtual ~ProfileData();

  ProfileData(const ProfileData& from);

  inline ProfileData& operator=(const ProfileData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProfileData(ProfileData&& from) noexcept
    : ProfileData() {
    *this = ::std::move(from);
  }

  inline ProfileData& operator=(ProfileData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ProfileData& default_instance();

  enum DataCase {
    kUint32Value = 1,
    kUint64Value = 2,
    kFloatValue = 3,
    kDoubleValue = 4,
    DATA_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProfileData* internal_default_instance() {
    return reinterpret_cast<const ProfileData*>(
               &_ProfileData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ProfileData* other);
  friend void swap(ProfileData& a, ProfileData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProfileData* New() const final {
    return CreateMaybeMessage<ProfileData>(nullptr);
  }

  ProfileData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProfileData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProfileData& from);
  void MergeFrom(const ProfileData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProfileData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .SCAMPProto.RepeatedUInt uint32_value = 1;
  bool has_uint32_value() const;
  void clear_uint32_value();
  static const int kUint32ValueFieldNumber = 1;
  const ::SCAMPProto::RepeatedUInt& uint32_value() const;
  ::SCAMPProto::RepeatedUInt* release_uint32_value();
  ::SCAMPProto::RepeatedUInt* mutable_uint32_value();
  void set_allocated_uint32_value(::SCAMPProto::RepeatedUInt* uint32_value);

  // .SCAMPProto.RepeatedULong uint64_value = 2;
  bool has_uint64_value() const;
  void clear_uint64_value();
  static const int kUint64ValueFieldNumber = 2;
  const ::SCAMPProto::RepeatedULong& uint64_value() const;
  ::SCAMPProto::RepeatedULong* release_uint64_value();
  ::SCAMPProto::RepeatedULong* mutable_uint64_value();
  void set_allocated_uint64_value(::SCAMPProto::RepeatedULong* uint64_value);

  // .SCAMPProto.RepeatedFloat float_value = 3;
  bool has_float_value() const;
  void clear_float_value();
  static const int kFloatValueFieldNumber = 3;
  const ::SCAMPProto::RepeatedFloat& float_value() const;
  ::SCAMPProto::RepeatedFloat* release_float_value();
  ::SCAMPProto::RepeatedFloat* mutable_float_value();
  void set_allocated_float_value(::SCAMPProto::RepeatedFloat* float_value);

  // .SCAMPProto.RepeatedDouble double_value = 4;
  bool has_double_value() const;
  void clear_double_value();
  static const int kDoubleValueFieldNumber = 4;
  const ::SCAMPProto::RepeatedDouble& double_value() const;
  ::SCAMPProto::RepeatedDouble* release_double_value();
  ::SCAMPProto::RepeatedDouble* mutable_double_value();
  void set_allocated_double_value(::SCAMPProto::RepeatedDouble* double_value);

  void clear_Data();
  DataCase Data_case() const;
  // @@protoc_insertion_point(class_scope:SCAMPProto.ProfileData)
 private:
  class HasBitSetters;
  void set_has_uint32_value();
  void set_has_uint64_value();
  void set_has_float_value();
  void set_has_double_value();

  inline bool has_Data() const;
  inline void clear_has_Data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union DataUnion {
    DataUnion() {}
    ::SCAMPProto::RepeatedUInt* uint32_value_;
    ::SCAMPProto::RepeatedULong* uint64_value_;
    ::SCAMPProto::RepeatedFloat* float_value_;
    ::SCAMPProto::RepeatedDouble* double_value_;
  } Data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_scamp_2eproto;
};
// -------------------------------------------------------------------

class Profile final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCAMPProto.Profile) */ {
 public:
  Profile();
  virtual ~Profile();

  Profile(const Profile& from);

  inline Profile& operator=(const Profile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Profile(Profile&& from) noexcept
    : Profile() {
    *this = ::std::move(from);
  }

  inline Profile& operator=(Profile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Profile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Profile* internal_default_instance() {
    return reinterpret_cast<const Profile*>(
               &_Profile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Profile* other);
  friend void swap(Profile& a, Profile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Profile* New() const final {
    return CreateMaybeMessage<Profile>(nullptr);
  }

  Profile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Profile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Profile& from);
  void MergeFrom(const Profile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Profile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SCAMPProto.ProfileData data = 1;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  ::SCAMPProto::ProfileData* mutable_data(int index);
  ::google::protobuf::RepeatedPtrField< ::SCAMPProto::ProfileData >*
      mutable_data();
  const ::SCAMPProto::ProfileData& data(int index) const;
  ::SCAMPProto::ProfileData* add_data();
  const ::google::protobuf::RepeatedPtrField< ::SCAMPProto::ProfileData >&
      data() const;

  // .SCAMPProto.SCAMPProfileType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::SCAMPProto::SCAMPProfileType type() const;
  void set_type(::SCAMPProto::SCAMPProfileType value);

  // @@protoc_insertion_point(class_scope:SCAMPProto.Profile)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::SCAMPProto::ProfileData > data_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scamp_2eproto;
};
// -------------------------------------------------------------------

class SCAMPTileInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCAMPProto.SCAMPTileInfo) */ {
 public:
  SCAMPTileInfo();
  virtual ~SCAMPTileInfo();

  SCAMPTileInfo(const SCAMPTileInfo& from);

  inline SCAMPTileInfo& operator=(const SCAMPTileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SCAMPTileInfo(SCAMPTileInfo&& from) noexcept
    : SCAMPTileInfo() {
    *this = ::std::move(from);
  }

  inline SCAMPTileInfo& operator=(SCAMPTileInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SCAMPTileInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SCAMPTileInfo* internal_default_instance() {
    return reinterpret_cast<const SCAMPTileInfo*>(
               &_SCAMPTileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(SCAMPTileInfo* other);
  friend void swap(SCAMPTileInfo& a, SCAMPTileInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SCAMPTileInfo* New() const final {
    return CreateMaybeMessage<SCAMPTileInfo>(nullptr);
  }

  SCAMPTileInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SCAMPTileInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SCAMPTileInfo& from);
  void MergeFrom(const SCAMPTileInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCAMPTileInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SCAMPProto.SCAMPTileInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scamp_2eproto;
};
// -------------------------------------------------------------------

class SCAMPArgs final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SCAMPProto.SCAMPArgs) */ {
 public:
  SCAMPArgs();
  virtual ~SCAMPArgs();

  SCAMPArgs(const SCAMPArgs& from);

  inline SCAMPArgs& operator=(const SCAMPArgs& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SCAMPArgs(SCAMPArgs&& from) noexcept
    : SCAMPArgs() {
    *this = ::std::move(from);
  }

  inline SCAMPArgs& operator=(SCAMPArgs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SCAMPArgs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SCAMPArgs* internal_default_instance() {
    return reinterpret_cast<const SCAMPArgs*>(
               &_SCAMPArgs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(SCAMPArgs* other);
  friend void swap(SCAMPArgs& a, SCAMPArgs& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SCAMPArgs* New() const final {
    return CreateMaybeMessage<SCAMPArgs>(nullptr);
  }

  SCAMPArgs* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SCAMPArgs>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SCAMPArgs& from);
  void MergeFrom(const SCAMPArgs& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCAMPArgs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double timeseries_a = 1;
  int timeseries_a_size() const;
  void clear_timeseries_a();
  static const int kTimeseriesAFieldNumber = 1;
  double timeseries_a(int index) const;
  void set_timeseries_a(int index, double value);
  void add_timeseries_a(double value);
  const ::google::protobuf::RepeatedField< double >&
      timeseries_a() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_timeseries_a();

  // repeated double timeseries_b = 2;
  int timeseries_b_size() const;
  void clear_timeseries_b();
  static const int kTimeseriesBFieldNumber = 2;
  double timeseries_b(int index) const;
  void set_timeseries_b(int index, double value);
  void add_timeseries_b(double value);
  const ::google::protobuf::RepeatedField< double >&
      timeseries_b() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_timeseries_b();

  // .SCAMPProto.Profile profile_a = 3;
  bool has_profile_a() const;
  void clear_profile_a();
  static const int kProfileAFieldNumber = 3;
  const ::SCAMPProto::Profile& profile_a() const;
  ::SCAMPProto::Profile* release_profile_a();
  ::SCAMPProto::Profile* mutable_profile_a();
  void set_allocated_profile_a(::SCAMPProto::Profile* profile_a);

  // .SCAMPProto.Profile profile_b = 4;
  bool has_profile_b() const;
  void clear_profile_b();
  static const int kProfileBFieldNumber = 4;
  const ::SCAMPProto::Profile& profile_b() const;
  ::SCAMPProto::Profile* release_profile_b();
  ::SCAMPProto::Profile* mutable_profile_b();
  void set_allocated_profile_b(::SCAMPProto::Profile* profile_b);

  // uint64 window = 6;
  void clear_window();
  static const int kWindowFieldNumber = 6;
  ::google::protobuf::uint64 window() const;
  void set_window(::google::protobuf::uint64 value);

  // uint64 max_tile_size = 7;
  void clear_max_tile_size();
  static const int kMaxTileSizeFieldNumber = 7;
  ::google::protobuf::uint64 max_tile_size() const;
  void set_max_tile_size(::google::protobuf::uint64 value);

  // int64 distributed_start_row = 8;
  void clear_distributed_start_row();
  static const int kDistributedStartRowFieldNumber = 8;
  ::google::protobuf::int64 distributed_start_row() const;
  void set_distributed_start_row(::google::protobuf::int64 value);

  // int64 distributed_start_col = 9;
  void clear_distributed_start_col();
  static const int kDistributedStartColFieldNumber = 9;
  ::google::protobuf::int64 distributed_start_col() const;
  void set_distributed_start_col(::google::protobuf::int64 value);

  // double distance_threshold = 10;
  void clear_distance_threshold();
  static const int kDistanceThresholdFieldNumber = 10;
  double distance_threshold() const;
  void set_distance_threshold(double value);

  // .SCAMPProto.SCAMPPrecisionType precision_type = 11;
  void clear_precision_type();
  static const int kPrecisionTypeFieldNumber = 11;
  ::SCAMPProto::SCAMPPrecisionType precision_type() const;
  void set_precision_type(::SCAMPProto::SCAMPPrecisionType value);

  // bool has_b = 5;
  void clear_has_b();
  static const int kHasBFieldNumber = 5;
  bool has_b() const;
  void set_has_b(bool value);

  // bool computing_rows = 13;
  void clear_computing_rows();
  static const int kComputingRowsFieldNumber = 13;
  bool computing_rows() const;
  void set_computing_rows(bool value);

  // bool computing_columns = 14;
  void clear_computing_columns();
  static const int kComputingColumnsFieldNumber = 14;
  bool computing_columns() const;
  void set_computing_columns(bool value);

  // bool keep_rows_separate = 15;
  void clear_keep_rows_separate();
  static const int kKeepRowsSeparateFieldNumber = 15;
  bool keep_rows_separate() const;
  void set_keep_rows_separate(bool value);

  // .SCAMPProto.SCAMPProfileType profile_type = 12;
  void clear_profile_type();
  static const int kProfileTypeFieldNumber = 12;
  ::SCAMPProto::SCAMPProfileType profile_type() const;
  void set_profile_type(::SCAMPProto::SCAMPProfileType value);

  // bool is_aligned = 16;
  void clear_is_aligned();
  static const int kIsAlignedFieldNumber = 16;
  bool is_aligned() const;
  void set_is_aligned(bool value);

  // int64 timeseries_size_a = 17;
  void clear_timeseries_size_a();
  static const int kTimeseriesSizeAFieldNumber = 17;
  ::google::protobuf::int64 timeseries_size_a() const;
  void set_timeseries_size_a(::google::protobuf::int64 value);

  // int64 timeseries_size_b = 18;
  void clear_timeseries_size_b();
  static const int kTimeseriesSizeBFieldNumber = 18;
  ::google::protobuf::int64 timeseries_size_b() const;
  void set_timeseries_size_b(::google::protobuf::int64 value);

  // int64 job_id = 19;
  void clear_job_id();
  static const int kJobIdFieldNumber = 19;
  ::google::protobuf::int64 job_id() const;
  void set_job_id(::google::protobuf::int64 value);

  // int64 tile_id = 20;
  void clear_tile_id();
  static const int kTileIdFieldNumber = 20;
  ::google::protobuf::int64 tile_id() const;
  void set_tile_id(::google::protobuf::int64 value);

  // int64 distributed_tile_size = 21;
  void clear_distributed_tile_size();
  static const int kDistributedTileSizeFieldNumber = 21;
  ::google::protobuf::int64 distributed_tile_size() const;
  void set_distributed_tile_size(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:SCAMPProto.SCAMPArgs)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > timeseries_a_;
  mutable std::atomic<int> _timeseries_a_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > timeseries_b_;
  mutable std::atomic<int> _timeseries_b_cached_byte_size_;
  ::SCAMPProto::Profile* profile_a_;
  ::SCAMPProto::Profile* profile_b_;
  ::google::protobuf::uint64 window_;
  ::google::protobuf::uint64 max_tile_size_;
  ::google::protobuf::int64 distributed_start_row_;
  ::google::protobuf::int64 distributed_start_col_;
  double distance_threshold_;
  int precision_type_;
  bool has_b_;
  bool computing_rows_;
  bool computing_columns_;
  bool keep_rows_separate_;
  int profile_type_;
  bool is_aligned_;
  ::google::protobuf::int64 timeseries_size_a_;
  ::google::protobuf::int64 timeseries_size_b_;
  ::google::protobuf::int64 job_id_;
  ::google::protobuf::int64 tile_id_;
  ::google::protobuf::int64 distributed_tile_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scamp_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SCAMPWork

// .SCAMPProto.SCAMPArgs args = 1;
inline bool SCAMPWork::has_args() const {
  return this != internal_default_instance() && args_ != nullptr;
}
inline void SCAMPWork::clear_args() {
  if (GetArenaNoVirtual() == nullptr && args_ != nullptr) {
    delete args_;
  }
  args_ = nullptr;
}
inline const ::SCAMPProto::SCAMPArgs& SCAMPWork::args() const {
  const ::SCAMPProto::SCAMPArgs* p = args_;
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPWork.args)
  return p != nullptr ? *p : *reinterpret_cast<const ::SCAMPProto::SCAMPArgs*>(
      &::SCAMPProto::_SCAMPArgs_default_instance_);
}
inline ::SCAMPProto::SCAMPArgs* SCAMPWork::release_args() {
  // @@protoc_insertion_point(field_release:SCAMPProto.SCAMPWork.args)
  
  ::SCAMPProto::SCAMPArgs* temp = args_;
  args_ = nullptr;
  return temp;
}
inline ::SCAMPProto::SCAMPArgs* SCAMPWork::mutable_args() {
  
  if (args_ == nullptr) {
    auto* p = CreateMaybeMessage<::SCAMPProto::SCAMPArgs>(GetArenaNoVirtual());
    args_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCAMPProto.SCAMPWork.args)
  return args_;
}
inline void SCAMPWork::set_allocated_args(::SCAMPProto::SCAMPArgs* args) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete args_;
  }
  if (args) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      args = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, args, submessage_arena);
    }
    
  } else {
    
  }
  args_ = args;
  // @@protoc_insertion_point(field_set_allocated:SCAMPProto.SCAMPWork.args)
}

// bool valid = 2;
inline void SCAMPWork::clear_valid() {
  valid_ = false;
}
inline bool SCAMPWork::valid() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPWork.valid)
  return valid_;
}
inline void SCAMPWork::set_valid(bool value) {
  
  valid_ = value;
  // @@protoc_insertion_point(field_set:SCAMPProto.SCAMPWork.valid)
}

// -------------------------------------------------------------------

// SCAMPStatus

// int64 job_id = 1;
inline void SCAMPStatus::clear_job_id() {
  job_id_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 SCAMPStatus::job_id() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPStatus.job_id)
  return job_id_;
}
inline void SCAMPStatus::set_job_id(::google::protobuf::int64 value) {
  
  job_id_ = value;
  // @@protoc_insertion_point(field_set:SCAMPProto.SCAMPStatus.job_id)
}

// .SCAMPProto.JobStatus status = 2;
inline void SCAMPStatus::clear_status() {
  status_ = 0;
}
inline ::SCAMPProto::JobStatus SCAMPStatus::status() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPStatus.status)
  return static_cast< ::SCAMPProto::JobStatus >(status_);
}
inline void SCAMPStatus::set_status(::SCAMPProto::JobStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:SCAMPProto.SCAMPStatus.status)
}

// float progress = 3;
inline void SCAMPStatus::clear_progress() {
  progress_ = 0;
}
inline float SCAMPStatus::progress() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPStatus.progress)
  return progress_;
}
inline void SCAMPStatus::set_progress(float value) {
  
  progress_ = value;
  // @@protoc_insertion_point(field_set:SCAMPProto.SCAMPStatus.progress)
}

// int64 time_elapsed = 4;
inline void SCAMPStatus::clear_time_elapsed() {
  time_elapsed_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 SCAMPStatus::time_elapsed() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPStatus.time_elapsed)
  return time_elapsed_;
}
inline void SCAMPStatus::set_time_elapsed(::google::protobuf::int64 value) {
  
  time_elapsed_ = value;
  // @@protoc_insertion_point(field_set:SCAMPProto.SCAMPStatus.time_elapsed)
}

// int64 eta = 5;
inline void SCAMPStatus::clear_eta() {
  eta_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 SCAMPStatus::eta() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPStatus.eta)
  return eta_;
}
inline void SCAMPStatus::set_eta(::google::protobuf::int64 value) {
  
  eta_ = value;
  // @@protoc_insertion_point(field_set:SCAMPProto.SCAMPStatus.eta)
}

// -------------------------------------------------------------------

// SCAMPJobID

// uint64 job_id = 1;
inline void SCAMPJobID::clear_job_id() {
  job_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SCAMPJobID::job_id() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPJobID.job_id)
  return job_id_;
}
inline void SCAMPJobID::set_job_id(::google::protobuf::uint64 value) {
  
  job_id_ = value;
  // @@protoc_insertion_point(field_set:SCAMPProto.SCAMPJobID.job_id)
}

// -------------------------------------------------------------------

// SCAMPRequest

// int64 expected_throughput = 1;
inline void SCAMPRequest::clear_expected_throughput() {
  expected_throughput_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 SCAMPRequest::expected_throughput() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPRequest.expected_throughput)
  return expected_throughput_;
}
inline void SCAMPRequest::set_expected_throughput(::google::protobuf::int64 value) {
  
  expected_throughput_ = value;
  // @@protoc_insertion_point(field_set:SCAMPProto.SCAMPRequest.expected_throughput)
}

// -------------------------------------------------------------------

// SCAMPResult

// -------------------------------------------------------------------

// RepeatedUInt

// repeated uint32 value = 1;
inline int RepeatedUInt::value_size() const {
  return value_.size();
}
inline void RepeatedUInt::clear_value() {
  value_.Clear();
}
inline ::google::protobuf::uint32 RepeatedUInt::value(int index) const {
  // @@protoc_insertion_point(field_get:SCAMPProto.RepeatedUInt.value)
  return value_.Get(index);
}
inline void RepeatedUInt::set_value(int index, ::google::protobuf::uint32 value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:SCAMPProto.RepeatedUInt.value)
}
inline void RepeatedUInt::add_value(::google::protobuf::uint32 value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:SCAMPProto.RepeatedUInt.value)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RepeatedUInt::value() const {
  // @@protoc_insertion_point(field_list:SCAMPProto.RepeatedUInt.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RepeatedUInt::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:SCAMPProto.RepeatedUInt.value)
  return &value_;
}

// -------------------------------------------------------------------

// RepeatedULong

// repeated uint64 value = 1;
inline int RepeatedULong::value_size() const {
  return value_.size();
}
inline void RepeatedULong::clear_value() {
  value_.Clear();
}
inline ::google::protobuf::uint64 RepeatedULong::value(int index) const {
  // @@protoc_insertion_point(field_get:SCAMPProto.RepeatedULong.value)
  return value_.Get(index);
}
inline void RepeatedULong::set_value(int index, ::google::protobuf::uint64 value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:SCAMPProto.RepeatedULong.value)
}
inline void RepeatedULong::add_value(::google::protobuf::uint64 value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:SCAMPProto.RepeatedULong.value)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
RepeatedULong::value() const {
  // @@protoc_insertion_point(field_list:SCAMPProto.RepeatedULong.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
RepeatedULong::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:SCAMPProto.RepeatedULong.value)
  return &value_;
}

// -------------------------------------------------------------------

// RepeatedFloat

// repeated float value = 1;
inline int RepeatedFloat::value_size() const {
  return value_.size();
}
inline void RepeatedFloat::clear_value() {
  value_.Clear();
}
inline float RepeatedFloat::value(int index) const {
  // @@protoc_insertion_point(field_get:SCAMPProto.RepeatedFloat.value)
  return value_.Get(index);
}
inline void RepeatedFloat::set_value(int index, float value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:SCAMPProto.RepeatedFloat.value)
}
inline void RepeatedFloat::add_value(float value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:SCAMPProto.RepeatedFloat.value)
}
inline const ::google::protobuf::RepeatedField< float >&
RepeatedFloat::value() const {
  // @@protoc_insertion_point(field_list:SCAMPProto.RepeatedFloat.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< float >*
RepeatedFloat::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:SCAMPProto.RepeatedFloat.value)
  return &value_;
}

// -------------------------------------------------------------------

// RepeatedDouble

// repeated double value = 1;
inline int RepeatedDouble::value_size() const {
  return value_.size();
}
inline void RepeatedDouble::clear_value() {
  value_.Clear();
}
inline double RepeatedDouble::value(int index) const {
  // @@protoc_insertion_point(field_get:SCAMPProto.RepeatedDouble.value)
  return value_.Get(index);
}
inline void RepeatedDouble::set_value(int index, double value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:SCAMPProto.RepeatedDouble.value)
}
inline void RepeatedDouble::add_value(double value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:SCAMPProto.RepeatedDouble.value)
}
inline const ::google::protobuf::RepeatedField< double >&
RepeatedDouble::value() const {
  // @@protoc_insertion_point(field_list:SCAMPProto.RepeatedDouble.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< double >*
RepeatedDouble::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:SCAMPProto.RepeatedDouble.value)
  return &value_;
}

// -------------------------------------------------------------------

// ProfileData

// .SCAMPProto.RepeatedUInt uint32_value = 1;
inline bool ProfileData::has_uint32_value() const {
  return Data_case() == kUint32Value;
}
inline void ProfileData::set_has_uint32_value() {
  _oneof_case_[0] = kUint32Value;
}
inline void ProfileData::clear_uint32_value() {
  if (has_uint32_value()) {
    delete Data_.uint32_value_;
    clear_has_Data();
  }
}
inline ::SCAMPProto::RepeatedUInt* ProfileData::release_uint32_value() {
  // @@protoc_insertion_point(field_release:SCAMPProto.ProfileData.uint32_value)
  if (has_uint32_value()) {
    clear_has_Data();
      ::SCAMPProto::RepeatedUInt* temp = Data_.uint32_value_;
    Data_.uint32_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SCAMPProto::RepeatedUInt& ProfileData::uint32_value() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.ProfileData.uint32_value)
  return has_uint32_value()
      ? *Data_.uint32_value_
      : *reinterpret_cast< ::SCAMPProto::RepeatedUInt*>(&::SCAMPProto::_RepeatedUInt_default_instance_);
}
inline ::SCAMPProto::RepeatedUInt* ProfileData::mutable_uint32_value() {
  if (!has_uint32_value()) {
    clear_Data();
    set_has_uint32_value();
    Data_.uint32_value_ = CreateMaybeMessage< ::SCAMPProto::RepeatedUInt >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCAMPProto.ProfileData.uint32_value)
  return Data_.uint32_value_;
}

// .SCAMPProto.RepeatedULong uint64_value = 2;
inline bool ProfileData::has_uint64_value() const {
  return Data_case() == kUint64Value;
}
inline void ProfileData::set_has_uint64_value() {
  _oneof_case_[0] = kUint64Value;
}
inline void ProfileData::clear_uint64_value() {
  if (has_uint64_value()) {
    delete Data_.uint64_value_;
    clear_has_Data();
  }
}
inline ::SCAMPProto::RepeatedULong* ProfileData::release_uint64_value() {
  // @@protoc_insertion_point(field_release:SCAMPProto.ProfileData.uint64_value)
  if (has_uint64_value()) {
    clear_has_Data();
      ::SCAMPProto::RepeatedULong* temp = Data_.uint64_value_;
    Data_.uint64_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SCAMPProto::RepeatedULong& ProfileData::uint64_value() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.ProfileData.uint64_value)
  return has_uint64_value()
      ? *Data_.uint64_value_
      : *reinterpret_cast< ::SCAMPProto::RepeatedULong*>(&::SCAMPProto::_RepeatedULong_default_instance_);
}
inline ::SCAMPProto::RepeatedULong* ProfileData::mutable_uint64_value() {
  if (!has_uint64_value()) {
    clear_Data();
    set_has_uint64_value();
    Data_.uint64_value_ = CreateMaybeMessage< ::SCAMPProto::RepeatedULong >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCAMPProto.ProfileData.uint64_value)
  return Data_.uint64_value_;
}

// .SCAMPProto.RepeatedFloat float_value = 3;
inline bool ProfileData::has_float_value() const {
  return Data_case() == kFloatValue;
}
inline void ProfileData::set_has_float_value() {
  _oneof_case_[0] = kFloatValue;
}
inline void ProfileData::clear_float_value() {
  if (has_float_value()) {
    delete Data_.float_value_;
    clear_has_Data();
  }
}
inline ::SCAMPProto::RepeatedFloat* ProfileData::release_float_value() {
  // @@protoc_insertion_point(field_release:SCAMPProto.ProfileData.float_value)
  if (has_float_value()) {
    clear_has_Data();
      ::SCAMPProto::RepeatedFloat* temp = Data_.float_value_;
    Data_.float_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SCAMPProto::RepeatedFloat& ProfileData::float_value() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.ProfileData.float_value)
  return has_float_value()
      ? *Data_.float_value_
      : *reinterpret_cast< ::SCAMPProto::RepeatedFloat*>(&::SCAMPProto::_RepeatedFloat_default_instance_);
}
inline ::SCAMPProto::RepeatedFloat* ProfileData::mutable_float_value() {
  if (!has_float_value()) {
    clear_Data();
    set_has_float_value();
    Data_.float_value_ = CreateMaybeMessage< ::SCAMPProto::RepeatedFloat >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCAMPProto.ProfileData.float_value)
  return Data_.float_value_;
}

// .SCAMPProto.RepeatedDouble double_value = 4;
inline bool ProfileData::has_double_value() const {
  return Data_case() == kDoubleValue;
}
inline void ProfileData::set_has_double_value() {
  _oneof_case_[0] = kDoubleValue;
}
inline void ProfileData::clear_double_value() {
  if (has_double_value()) {
    delete Data_.double_value_;
    clear_has_Data();
  }
}
inline ::SCAMPProto::RepeatedDouble* ProfileData::release_double_value() {
  // @@protoc_insertion_point(field_release:SCAMPProto.ProfileData.double_value)
  if (has_double_value()) {
    clear_has_Data();
      ::SCAMPProto::RepeatedDouble* temp = Data_.double_value_;
    Data_.double_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SCAMPProto::RepeatedDouble& ProfileData::double_value() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.ProfileData.double_value)
  return has_double_value()
      ? *Data_.double_value_
      : *reinterpret_cast< ::SCAMPProto::RepeatedDouble*>(&::SCAMPProto::_RepeatedDouble_default_instance_);
}
inline ::SCAMPProto::RepeatedDouble* ProfileData::mutable_double_value() {
  if (!has_double_value()) {
    clear_Data();
    set_has_double_value();
    Data_.double_value_ = CreateMaybeMessage< ::SCAMPProto::RepeatedDouble >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SCAMPProto.ProfileData.double_value)
  return Data_.double_value_;
}

inline bool ProfileData::has_Data() const {
  return Data_case() != DATA_NOT_SET;
}
inline void ProfileData::clear_has_Data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline ProfileData::DataCase ProfileData::Data_case() const {
  return ProfileData::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Profile

// repeated .SCAMPProto.ProfileData data = 1;
inline int Profile::data_size() const {
  return data_.size();
}
inline void Profile::clear_data() {
  data_.Clear();
}
inline ::SCAMPProto::ProfileData* Profile::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:SCAMPProto.Profile.data)
  return data_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SCAMPProto::ProfileData >*
Profile::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:SCAMPProto.Profile.data)
  return &data_;
}
inline const ::SCAMPProto::ProfileData& Profile::data(int index) const {
  // @@protoc_insertion_point(field_get:SCAMPProto.Profile.data)
  return data_.Get(index);
}
inline ::SCAMPProto::ProfileData* Profile::add_data() {
  // @@protoc_insertion_point(field_add:SCAMPProto.Profile.data)
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCAMPProto::ProfileData >&
Profile::data() const {
  // @@protoc_insertion_point(field_list:SCAMPProto.Profile.data)
  return data_;
}

// .SCAMPProto.SCAMPProfileType type = 2;
inline void Profile::clear_type() {
  type_ = 0;
}
inline ::SCAMPProto::SCAMPProfileType Profile::type() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.Profile.type)
  return static_cast< ::SCAMPProto::SCAMPProfileType >(type_);
}
inline void Profile::set_type(::SCAMPProto::SCAMPProfileType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:SCAMPProto.Profile.type)
}

// -------------------------------------------------------------------

// SCAMPTileInfo

// -------------------------------------------------------------------

// SCAMPArgs

// repeated double timeseries_a = 1;
inline int SCAMPArgs::timeseries_a_size() const {
  return timeseries_a_.size();
}
inline void SCAMPArgs::clear_timeseries_a() {
  timeseries_a_.Clear();
}
inline double SCAMPArgs::timeseries_a(int index) const {
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPArgs.timeseries_a)
  return timeseries_a_.Get(index);
}
inline void SCAMPArgs::set_timeseries_a(int index, double value) {
  timeseries_a_.Set(index, value);
  // @@protoc_insertion_point(field_set:SCAMPProto.SCAMPArgs.timeseries_a)
}
inline void SCAMPArgs::add_timeseries_a(double value) {
  timeseries_a_.Add(value);
  // @@protoc_insertion_point(field_add:SCAMPProto.SCAMPArgs.timeseries_a)
}
inline const ::google::protobuf::RepeatedField< double >&
SCAMPArgs::timeseries_a() const {
  // @@protoc_insertion_point(field_list:SCAMPProto.SCAMPArgs.timeseries_a)
  return timeseries_a_;
}
inline ::google::protobuf::RepeatedField< double >*
SCAMPArgs::mutable_timeseries_a() {
  // @@protoc_insertion_point(field_mutable_list:SCAMPProto.SCAMPArgs.timeseries_a)
  return &timeseries_a_;
}

// repeated double timeseries_b = 2;
inline int SCAMPArgs::timeseries_b_size() const {
  return timeseries_b_.size();
}
inline void SCAMPArgs::clear_timeseries_b() {
  timeseries_b_.Clear();
}
inline double SCAMPArgs::timeseries_b(int index) const {
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPArgs.timeseries_b)
  return timeseries_b_.Get(index);
}
inline void SCAMPArgs::set_timeseries_b(int index, double value) {
  timeseries_b_.Set(index, value);
  // @@protoc_insertion_point(field_set:SCAMPProto.SCAMPArgs.timeseries_b)
}
inline void SCAMPArgs::add_timeseries_b(double value) {
  timeseries_b_.Add(value);
  // @@protoc_insertion_point(field_add:SCAMPProto.SCAMPArgs.timeseries_b)
}
inline const ::google::protobuf::RepeatedField< double >&
SCAMPArgs::timeseries_b() const {
  // @@protoc_insertion_point(field_list:SCAMPProto.SCAMPArgs.timeseries_b)
  return timeseries_b_;
}
inline ::google::protobuf::RepeatedField< double >*
SCAMPArgs::mutable_timeseries_b() {
  // @@protoc_insertion_point(field_mutable_list:SCAMPProto.SCAMPArgs.timeseries_b)
  return &timeseries_b_;
}

// .SCAMPProto.Profile profile_a = 3;
inline bool SCAMPArgs::has_profile_a() const {
  return this != internal_default_instance() && profile_a_ != nullptr;
}
inline void SCAMPArgs::clear_profile_a() {
  if (GetArenaNoVirtual() == nullptr && profile_a_ != nullptr) {
    delete profile_a_;
  }
  profile_a_ = nullptr;
}
inline const ::SCAMPProto::Profile& SCAMPArgs::profile_a() const {
  const ::SCAMPProto::Profile* p = profile_a_;
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPArgs.profile_a)
  return p != nullptr ? *p : *reinterpret_cast<const ::SCAMPProto::Profile*>(
      &::SCAMPProto::_Profile_default_instance_);
}
inline ::SCAMPProto::Profile* SCAMPArgs::release_profile_a() {
  // @@protoc_insertion_point(field_release:SCAMPProto.SCAMPArgs.profile_a)
  
  ::SCAMPProto::Profile* temp = profile_a_;
  profile_a_ = nullptr;
  return temp;
}
inline ::SCAMPProto::Profile* SCAMPArgs::mutable_profile_a() {
  
  if (profile_a_ == nullptr) {
    auto* p = CreateMaybeMessage<::SCAMPProto::Profile>(GetArenaNoVirtual());
    profile_a_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCAMPProto.SCAMPArgs.profile_a)
  return profile_a_;
}
inline void SCAMPArgs::set_allocated_profile_a(::SCAMPProto::Profile* profile_a) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete profile_a_;
  }
  if (profile_a) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      profile_a = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, profile_a, submessage_arena);
    }
    
  } else {
    
  }
  profile_a_ = profile_a;
  // @@protoc_insertion_point(field_set_allocated:SCAMPProto.SCAMPArgs.profile_a)
}

// .SCAMPProto.Profile profile_b = 4;
inline bool SCAMPArgs::has_profile_b() const {
  return this != internal_default_instance() && profile_b_ != nullptr;
}
inline void SCAMPArgs::clear_profile_b() {
  if (GetArenaNoVirtual() == nullptr && profile_b_ != nullptr) {
    delete profile_b_;
  }
  profile_b_ = nullptr;
}
inline const ::SCAMPProto::Profile& SCAMPArgs::profile_b() const {
  const ::SCAMPProto::Profile* p = profile_b_;
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPArgs.profile_b)
  return p != nullptr ? *p : *reinterpret_cast<const ::SCAMPProto::Profile*>(
      &::SCAMPProto::_Profile_default_instance_);
}
inline ::SCAMPProto::Profile* SCAMPArgs::release_profile_b() {
  // @@protoc_insertion_point(field_release:SCAMPProto.SCAMPArgs.profile_b)
  
  ::SCAMPProto::Profile* temp = profile_b_;
  profile_b_ = nullptr;
  return temp;
}
inline ::SCAMPProto::Profile* SCAMPArgs::mutable_profile_b() {
  
  if (profile_b_ == nullptr) {
    auto* p = CreateMaybeMessage<::SCAMPProto::Profile>(GetArenaNoVirtual());
    profile_b_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SCAMPProto.SCAMPArgs.profile_b)
  return profile_b_;
}
inline void SCAMPArgs::set_allocated_profile_b(::SCAMPProto::Profile* profile_b) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete profile_b_;
  }
  if (profile_b) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      profile_b = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, profile_b, submessage_arena);
    }
    
  } else {
    
  }
  profile_b_ = profile_b;
  // @@protoc_insertion_point(field_set_allocated:SCAMPProto.SCAMPArgs.profile_b)
}

// bool has_b = 5;
inline void SCAMPArgs::clear_has_b() {
  has_b_ = false;
}
inline bool SCAMPArgs::has_b() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPArgs.has_b)
  return has_b_;
}
inline void SCAMPArgs::set_has_b(bool value) {
  
  has_b_ = value;
  // @@protoc_insertion_point(field_set:SCAMPProto.SCAMPArgs.has_b)
}

// uint64 window = 6;
inline void SCAMPArgs::clear_window() {
  window_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SCAMPArgs::window() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPArgs.window)
  return window_;
}
inline void SCAMPArgs::set_window(::google::protobuf::uint64 value) {
  
  window_ = value;
  // @@protoc_insertion_point(field_set:SCAMPProto.SCAMPArgs.window)
}

// uint64 max_tile_size = 7;
inline void SCAMPArgs::clear_max_tile_size() {
  max_tile_size_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SCAMPArgs::max_tile_size() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPArgs.max_tile_size)
  return max_tile_size_;
}
inline void SCAMPArgs::set_max_tile_size(::google::protobuf::uint64 value) {
  
  max_tile_size_ = value;
  // @@protoc_insertion_point(field_set:SCAMPProto.SCAMPArgs.max_tile_size)
}

// int64 distributed_start_row = 8;
inline void SCAMPArgs::clear_distributed_start_row() {
  distributed_start_row_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 SCAMPArgs::distributed_start_row() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPArgs.distributed_start_row)
  return distributed_start_row_;
}
inline void SCAMPArgs::set_distributed_start_row(::google::protobuf::int64 value) {
  
  distributed_start_row_ = value;
  // @@protoc_insertion_point(field_set:SCAMPProto.SCAMPArgs.distributed_start_row)
}

// int64 distributed_start_col = 9;
inline void SCAMPArgs::clear_distributed_start_col() {
  distributed_start_col_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 SCAMPArgs::distributed_start_col() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPArgs.distributed_start_col)
  return distributed_start_col_;
}
inline void SCAMPArgs::set_distributed_start_col(::google::protobuf::int64 value) {
  
  distributed_start_col_ = value;
  // @@protoc_insertion_point(field_set:SCAMPProto.SCAMPArgs.distributed_start_col)
}

// double distance_threshold = 10;
inline void SCAMPArgs::clear_distance_threshold() {
  distance_threshold_ = 0;
}
inline double SCAMPArgs::distance_threshold() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPArgs.distance_threshold)
  return distance_threshold_;
}
inline void SCAMPArgs::set_distance_threshold(double value) {
  
  distance_threshold_ = value;
  // @@protoc_insertion_point(field_set:SCAMPProto.SCAMPArgs.distance_threshold)
}

// .SCAMPProto.SCAMPPrecisionType precision_type = 11;
inline void SCAMPArgs::clear_precision_type() {
  precision_type_ = 0;
}
inline ::SCAMPProto::SCAMPPrecisionType SCAMPArgs::precision_type() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPArgs.precision_type)
  return static_cast< ::SCAMPProto::SCAMPPrecisionType >(precision_type_);
}
inline void SCAMPArgs::set_precision_type(::SCAMPProto::SCAMPPrecisionType value) {
  
  precision_type_ = value;
  // @@protoc_insertion_point(field_set:SCAMPProto.SCAMPArgs.precision_type)
}

// .SCAMPProto.SCAMPProfileType profile_type = 12;
inline void SCAMPArgs::clear_profile_type() {
  profile_type_ = 0;
}
inline ::SCAMPProto::SCAMPProfileType SCAMPArgs::profile_type() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPArgs.profile_type)
  return static_cast< ::SCAMPProto::SCAMPProfileType >(profile_type_);
}
inline void SCAMPArgs::set_profile_type(::SCAMPProto::SCAMPProfileType value) {
  
  profile_type_ = value;
  // @@protoc_insertion_point(field_set:SCAMPProto.SCAMPArgs.profile_type)
}

// bool computing_rows = 13;
inline void SCAMPArgs::clear_computing_rows() {
  computing_rows_ = false;
}
inline bool SCAMPArgs::computing_rows() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPArgs.computing_rows)
  return computing_rows_;
}
inline void SCAMPArgs::set_computing_rows(bool value) {
  
  computing_rows_ = value;
  // @@protoc_insertion_point(field_set:SCAMPProto.SCAMPArgs.computing_rows)
}

// bool computing_columns = 14;
inline void SCAMPArgs::clear_computing_columns() {
  computing_columns_ = false;
}
inline bool SCAMPArgs::computing_columns() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPArgs.computing_columns)
  return computing_columns_;
}
inline void SCAMPArgs::set_computing_columns(bool value) {
  
  computing_columns_ = value;
  // @@protoc_insertion_point(field_set:SCAMPProto.SCAMPArgs.computing_columns)
}

// bool keep_rows_separate = 15;
inline void SCAMPArgs::clear_keep_rows_separate() {
  keep_rows_separate_ = false;
}
inline bool SCAMPArgs::keep_rows_separate() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPArgs.keep_rows_separate)
  return keep_rows_separate_;
}
inline void SCAMPArgs::set_keep_rows_separate(bool value) {
  
  keep_rows_separate_ = value;
  // @@protoc_insertion_point(field_set:SCAMPProto.SCAMPArgs.keep_rows_separate)
}

// bool is_aligned = 16;
inline void SCAMPArgs::clear_is_aligned() {
  is_aligned_ = false;
}
inline bool SCAMPArgs::is_aligned() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPArgs.is_aligned)
  return is_aligned_;
}
inline void SCAMPArgs::set_is_aligned(bool value) {
  
  is_aligned_ = value;
  // @@protoc_insertion_point(field_set:SCAMPProto.SCAMPArgs.is_aligned)
}

// int64 timeseries_size_a = 17;
inline void SCAMPArgs::clear_timeseries_size_a() {
  timeseries_size_a_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 SCAMPArgs::timeseries_size_a() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPArgs.timeseries_size_a)
  return timeseries_size_a_;
}
inline void SCAMPArgs::set_timeseries_size_a(::google::protobuf::int64 value) {
  
  timeseries_size_a_ = value;
  // @@protoc_insertion_point(field_set:SCAMPProto.SCAMPArgs.timeseries_size_a)
}

// int64 timeseries_size_b = 18;
inline void SCAMPArgs::clear_timeseries_size_b() {
  timeseries_size_b_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 SCAMPArgs::timeseries_size_b() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPArgs.timeseries_size_b)
  return timeseries_size_b_;
}
inline void SCAMPArgs::set_timeseries_size_b(::google::protobuf::int64 value) {
  
  timeseries_size_b_ = value;
  // @@protoc_insertion_point(field_set:SCAMPProto.SCAMPArgs.timeseries_size_b)
}

// int64 job_id = 19;
inline void SCAMPArgs::clear_job_id() {
  job_id_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 SCAMPArgs::job_id() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPArgs.job_id)
  return job_id_;
}
inline void SCAMPArgs::set_job_id(::google::protobuf::int64 value) {
  
  job_id_ = value;
  // @@protoc_insertion_point(field_set:SCAMPProto.SCAMPArgs.job_id)
}

// int64 tile_id = 20;
inline void SCAMPArgs::clear_tile_id() {
  tile_id_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 SCAMPArgs::tile_id() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPArgs.tile_id)
  return tile_id_;
}
inline void SCAMPArgs::set_tile_id(::google::protobuf::int64 value) {
  
  tile_id_ = value;
  // @@protoc_insertion_point(field_set:SCAMPProto.SCAMPArgs.tile_id)
}

// int64 distributed_tile_size = 21;
inline void SCAMPArgs::clear_distributed_tile_size() {
  distributed_tile_size_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 SCAMPArgs::distributed_tile_size() const {
  // @@protoc_insertion_point(field_get:SCAMPProto.SCAMPArgs.distributed_tile_size)
  return distributed_tile_size_;
}
inline void SCAMPArgs::set_distributed_tile_size(::google::protobuf::int64 value) {
  
  distributed_tile_size_ = value;
  // @@protoc_insertion_point(field_set:SCAMPProto.SCAMPArgs.distributed_tile_size)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace SCAMPProto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::SCAMPProto::JobStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCAMPProto::JobStatus>() {
  return ::SCAMPProto::JobStatus_descriptor();
}
template <> struct is_proto_enum< ::SCAMPProto::SCAMPProfileType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCAMPProto::SCAMPProfileType>() {
  return ::SCAMPProto::SCAMPProfileType_descriptor();
}
template <> struct is_proto_enum< ::SCAMPProto::SCAMPPrecisionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCAMPProto::SCAMPPrecisionType>() {
  return ::SCAMPProto::SCAMPPrecisionType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_scamp_2eproto
